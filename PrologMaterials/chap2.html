<html>
<body>
<hr>
<h2>
Representing facts
</h2>

<p>If we want computers to act intelligent, we must help them.
We must tell them all the common-sense <em>knowledge</strong></em> we have that
they don't.  This can be hard because this knowledge can be
so obvious to us that we don't realize that a computer doesn't know
it too, but we must try.

<p>Now there are many different kinds of knowledge.  Without getting
deep into philosophy (or specifically <em>epistemology</strong></em>, the theory
of knowledge), there are two main kinds: facts and reasoning procedures.
Facts are things true about the world, and reasoning procedures (or
<em>inferences</strong></em>) are ways to follow reasoning chains between facts.  Since
facts are easier to represent than procedures, we'll consider them first,
and postpone procedures to Chapter 4.

<p>
<h3>
Predicates and predicate expressions
</h3>

<p>To talk about facts we need a "language".  Artificial
intelligence uses many languages and sub-languages.  But in this
introductory book we don't want to confuse you.  We'll use only one,
simple (<em>first-order</strong></em>) <em>predicate logic</strong></em> (sometimes called
<em>predicate calculus</strong></em> and sometimes just <em>logic</strong></em>).  And
we'll use a particular notation compatible with the computer programming
language Prolog | REFERENCE 1|.
.FS
 | REFERENCE 1|
In this book we use a subset of the "standard Prolog" in Clocksin and Mellish,
<em>Programming in Prolog</strong></em>, second edition, Springer-Verlag, 1984.
For a complete description of what we use, see Appendix D.
.FE
Prolog isn't predicate logic itself; computer
languages try to do things, whereas logic just says
that certain things are true and false.  But Prolog does appear close to
the way logic is usually written.  That is, its <em>grammar</strong></em> or <em>syntax</strong></em>
or form is that of logic, but its <em>semantics</strong></em> or meaning is different.

<p>And what is that grammar?  Formally, a <em>predicate expression</strong></em> (or
<em>atomic formula</strong></em>, but that sounds like a nuclear weapons secret)
is a name--a <em>predicate</strong></em>--followed by zero or more arguments enclosed in
parentheses and separated by commas (see Figure 2-1) | REFERENCE 2|.
.FS
 | REFERENCE 2| Several terms closely related to "predicate
expression" are used in the logic and artificial-intelligence literature.
A <em>literal</strong></em> is like a predicate expression only it can have a negation
symbol in front of it (negations will be explained in Section 3.6).  A
<em>structure</strong></em> or <em>compound term</strong></em> is like a predicate expression only
it isn't necessarily only true or false.  A <em>logical formula</strong></em> is
a structure or a set of structures put together with "and"s, "or"s, and "not"s.
.FE
Predicate names and arguments can be composed of any mixture of
letters and numbers, except that predicate names must start with a lower-case
letter.  (Upper-case letters first in a word have a special meaning in Prolog,
as we'll explain shortly.)  The underscore symbol "<strong>_</strong></em>"
also counts as a letter, and we will often use it to make names more readable.
So these are all predicate expressions:
<pre>
p(x)
q(y,3)
r(alpha,-2584,beta)
city(monterey,california)
tuvwxy(abc345)
noarguments
pi(3.1416)
long_predicate_name(long_argument_name,3)
</pre>

<p>We can put predicate expressions like these into computers.  They can
represent facts true about the world.  But what exactly do these expressions
<em>mean</strong></em> (their <em>semantics</strong></em>)?  Actually, anything you want--it's up to
you to assign reasonable and consistent interpretations to the symbols
and the way they're put together, though there are some conventions.
The better job you do, the more reasonable the conclusions you'll reach
from all these facts.

<p>
<h3>
Predicates indicating types
</h3>

<p>Predicates can mean many things.  But they do fall into categories.
We summarize the major categories in Figure 2-2.

<p>One thing they can mean is something like data-type information in
a language like Pascal or Ada.  Except that in artificial intelligence
there are generally a lot more types than there are
in most programming, because there must be a type for every
category in the world that we want the computer to know about.

<p>For instance, suppose we want the computer to know about some U.S. Navy
ships | REFERENCE 3|.  We
.FS
 | REFERENCE 3| The occasional use of military examples
in this book is deliberate: to serve as a reminder that
much artificial intelligence work in the United States has been, and
remains, supported by the military.  We make no endorsements.
.FE
could tell it
<pre>
ship(enterprise).
</pre>
to say that the Enterprise is a ship (remember we must use lower case).
Or in other words, the Enterprise is an example of the "ship" type.
We will put periods at the end of facts because Prolog uses the period
to signal the end of a line.  We could also tell the computer
<pre>
ship(kennedy).
ship(vinson).
</pre>
to give it the names of two more ships--two more things of the "ship" type.
Here <strong>ship</strong></em> is a <em>type predicate</strong></em>.  If we knew code numbers for planes
we could tell the computer about them too, using the code numbers as names:
<pre>
plane(p54862).
plane(p79313).
</pre>
Similarly, we can label people with types:
<pre>
commodore(r_h_shumaker).
president(r_reagan).
</pre>
and label more abstract things like institutions:
<pre>
university(naval_postgraduate_school).
university(stanford_university).
</pre>
and label concepts:
<pre>
day_of_week(monday).
day_of_week(tuesday).
day_of_week(wednesday).
</pre>

<p>A thing can have more than one type.  For instance:
<pre>
ship(enterprise).
american(enterprise).
</pre>
And types can have subtypes:
<pre>
carrier(vinson).
ship(carrier).
</pre>

<p>These are all <em>type predicates</strong></em>, and they are all have
one argument.  The argument is the name of some thing
in the world, and the predicate name is the class or category
it belongs to.  So the predicate name is
<em>more general</strong></em>
than the argument name; this is usual for predicate names in
artificial intelligence.  So it wouldn't be as good to say
<pre>
enterprise(ship).
kennedy(ship).
</pre>

<p>
<h3>
About types
</h3>

<p>We've said these predicates are like the types in computer languages,
but there are some differences.
The main one is that they need never be defined anywhere.
If for instance we are using Pascal, we either use the built-in
types (integer, real, character, array, and pointer) or define the type
we want in terms of those built-in types.  But for artificial intelligence,
the type (predicate) names are just arbitrary codes used in lookup.
This is because you can put integers and characters in a computer, but not
a ship.  You can't even put in a full representation of a ship, or a full
representation of any other real object--real objects have too many
complexities, while integers and characters are abstractions.

<p>How then, if we expect the computer to be intelligent, will it ever
know what a ship is?  Much the way people know.  Ships are
defined in a dictionary using the concept of a vehicle, the
concept of water, the concept of floating, and so on.
A dictionary might say a ship is "an
oceangoing vessel".  But it might define "vessel" as a "craft for travelling
on water", and "craft" as an "individual ship"--so
the definitions are circular, as all dictionary definitions are
sooner or later.  But we can indirectly figure out what is being
talked about by the secondary words like "oceangoing" and "travelling".
So words must be defined in terms of one another.

<p>So we won't expect each type predicate to be <em>implemented</strong></em> (that is,
understood by a computer) by a separate procedure or processing routine.
The same holds for arguments.  In fact, we could
store all predicate names and arguments the same way in the computer,
as characters.  This is a bit wasteful of computer storage space--so some
Prolog dialects do store numbers differently--but there's nothing wrong
philosophically with it.

<p>
<h3>
Good naming
</h3>

<p>So predicate and argument names can be arbitrary; we just have to remember
what they represent.  But one name can be better than another, if it is
easier to remember what it means.  Writing facts
for an artificial-intelligence program to use is a kind
of programming, and we should follow the usual rules of good programming
style.  In choosing names, we suggest these guidelines:
<blockquote>
1.  As much as possible, use everyday English words for names.  If you need
more than one word, use the underscore character between them for clarity,
like in <strong>day_of_week</strong></em> (though sometimes you can leave out the
underscores like in <strong>dayofweek</strong></em> when the reading is reasonably clear).

<p>2.  Choose names that describe their function precisely.  For instance,
use <strong>day_of_week</strong></em> instead of <strong>day</strong></em>, which could describe both
<strong>monday</strong></em> and <strong>october_19_1985</strong></em>.

<p>3.  Avoid names with multiple meanings.
For instance, if there is a Commander Kennedy as well as a ship
named Kennedy, include the first initial of the person; or if you call
the Enterprise a "ship", don't also say that a unit "shipped" somewhere.

<p>4.  Avoid numbers in names, with two exceptions: arithmetic
(see Chapter 5) and closely related variables and predicates
(like <strong>X</strong></em> and <strong>X2</strong></em> in Section 5.5 and <strong>iterate</strong></em> and
<strong>iterate2</strong></em> in Section 10.8).

<p>5.  Abbreviate only when absolutely necessary.  Since artificial intelligence
programs often use many names, abbreviations can be confusing.

<p>6. Predicate names should be more general than their argument names, but not
so general that they don't really mean anything (for then facts can't
be indexed well).

<p>7. A few predicate names are reserved or "special" to Prolog, so you
can't use them for your own predicates.

<p>8. Of course, always use the same name for the same thing.
</blockquote>

<p>
<h3>
Property predicates
</h3>

<p>We can tell the computer (or <em>assert</strong></em>):
<pre>
ship(enterprise).
gray(enterprise).
big(enterprise).
</pre>
which could mean "The Enterprise is a ship, it is gray, and it is big."
(Never mind that "big" is vague; we could
define it as "more than 800 feet long", and "gray" and even "ship"
are vague to a lesser extent (is a toy ship a ship? and is
an imaginary ship a ship?), and much human knowledge is vague anyway.)
Or this could mean the Enterprise is a member of the class of ships,
a member of the class of gray things, and a member of the class
of big things.  But those last two phrases awkward. "Gray" and
"big" are adjectives, not nouns like "ship", and they should be treated
differently.

<p>So we'll represent properties of objects as
<em>property predicate expressions</strong></em>, two-argument expressions in which
the predicate name is the name of a property, the first argument is
the name of an object, and the second argument is the value of the
property.  The preceding example could be rewritten better as:
<pre>
ship(enterprise).
color(enterprise,gray).
size(enterprise,big).
</pre>
This has the advantage of using predicate names that are more general.
It also shows the relation between <strong>gray</strong></em> and <strong>enterprise</strong></em>, and that
between <strong>big</strong></em> and <strong>enterprise</strong></em>: <strong>color</strong></em> and <strong>size</strong></em> are the property
names for which <strong>gray</strong></em> and <strong>big</strong></em> are the values.
So we've made some implicit (unstated "common-sense") knowledge explicit
(stated), a key goal in artificial intelligence.

<p>Again, the computer won't actually know what <strong>gray</strong></em> and <strong>big</strong></em> mean
if we type in the preceding three example lines; those are just codes that it
uses for comparison.  For instance, if the computer also knows
<pre>
color(kennedy,gray).
</pre>
then it knows the Enterprise and the Kennedy have the same color,
though it doesn't know what a "color" is (but don't blame it, because
most computers don't have eyes).

<p>An important class of property predicates concern space and time.
For instance
<pre>
location(enterprise,14n35e).
last_docking(enterprise,16feb85).
</pre>
could mean that the Enterprise is currently at latitude 14N and
longitude 35E, and its last docking was on February 16, 1985.

<p>
<h3>
Predicates for relationships
</h3>

<p>Perhaps the most important predicates of all relate two
different things.  Such <em>relationship predicates</strong></em> are
important because a lot of human reasoning seems to use them--people
need to relate ideas.  For instance, we can use a <strong>part_of</strong></em>
predicate of two arguments which says that its first argument is a component
within its second argument.  We could give as facts:
<pre>
part_of(enterprise,u_s_navy).
part_of(u_s_navy,u_s_government).
part_of(naval_postgraduate_school,u_s_government).
part_of(propulsion_system,ship).
</pre>
In other words, the Enterprise is part of the U.S. Navy, the
Navy is part of the U.S. government, the Naval Postgraduate School
is part of the U.S. government, and the propulsion system is part of a ship.
An <strong>owns</strong></em> relationship predicate can say that something
is owned by someone:
<pre>
owns(tom,fido).
owns(tom,toms_car).
</pre>
These facts say that Tom owns two things: something called <strong>fido</strong></em>, and
an unnamed car which we can just refer to as <strong>toms_car</strong></em>.

<p>It's easy to get confused about argument order in relationship
predicate expressions.  So we'll try to follow this convention: if the
predicate name is inserted between the two arguments, the result will be
close to an English sentence giving the correct meaning.
So if we insert "owns" between "tom" and "fido" we get
"Tom owns Fido", and if we insert "part of" between "enterprise" and
"u. s. navy" we get "Enterprise part of U. S. Navy".

<p>An important class of relationship predicates relates things in space
and time.  A real-world object can be north, south, east, west, etc. of
another object.  Viewed by a fixed observer, an object can also be
right, left, above, below, in front, and behind another object.
We can describe a picture with these predicates.  Similarly, an event in
time can be before, after, during, overlapping, or simultaneous with
another event, so we can describe history with these predicates.

<p>Relationship predicates can describe relationships between people.
For instance, the <strong>boss_of</strong></em> relationship is important for
describing bureaucracies, an important application of
artificial intelligence.  It says that a person (first argument) is
the boss of another person (second argument), and this shows direction
of responsibility.  People can also be related by
kinship relationship predicates (<strong>father</strong></em>, <strong>mother</strong></em>,
<strong>child</strong></em>, <strong>uncle</strong></em>, <strong>cousin</strong></em>, <strong>stepfather</strong></em>,
<strong>half-brother</strong></em>, <strong>grandfather</strong></em>, etc.).  People can also be
related with <strong>friend</strong></em> and <strong>acquaintance</strong></em> relationship predicates.

<p>Besides all these, another special relationship predicate is frequently
used in artificial intelligence.  It's called <strong>a_kind_of</strong></em> or
<strong>is_a</strong></em> (we prefer the first name, because "is" is vague),
and it can replace all type predicates.  Its first argument is a thing,
and its second argument is the type of that thing (the predicate name in
the one-argument form considered before).  For instance:
<pre>
a_kind_of(enterprise,ship).
a_kind_of(tanker,ship).
a_kind_of(tuesday,day_of_week).
</pre>
which says that the Enterprise is a kind of ship, a tanker is a kind
of ship, and Tuesday is a kind of day of the week | REFERENCE 4|.
.FS
 | REFERENCE 4| Some researchers don't agree with this use of
<strong>a_kind_of</strong></em>.  They think that the first two facts should
have different predicate names since the Enterprise is an
individual while tankers are a group of individuals; often they'll use
the predicate name <strong>element</strong></em> for the "Enterprise" fact, and keep
<strong>a_kind_of</strong></em> for the "tanker" fact.  But a set whose
size is 1 is still a set, and there doesn't seem to be anything fundamentally
different between restricting the body type of a ship to be a tanker
and restricting the name of a ship to be the word "Enterprise"--it
just happens that people try, not always successfully, to make names
unique.  Researchers who argue against this may be getting this issue
confused with the important "extensions vs. intensions" problem
which we'll discuss in Section 12.8.
.FE
Some reasoning is easier with this two-argument
form than the equivalent one-argument form.

<p>There are other predicates, but as any
psychotherapist will tell you, relationships are the key to a happy life.

<p>
<h3>
Semantic networks
</h3>

<p>Pictures can make a complicated set of facts a lot clearer.
There's a simple pictorial way to show the predicate expressions we've
been discussing: the <em>semantic network</strong></em>.  Unfortunately,
there is a major restriction: semantic networks can only directly
represent predicates of two arguments (so type predicates must be in
the two-argument form) | REFERENCE 5|.
.FS
 | REFERENCE 5| But we can represent predicate expressions with more
than two arguments indirectly, as sets of two-argument predicate expressions.
.FE

<p>A semantic network is what computer scientists call a a <em>labeled
directed graph</strong></em> (see Appendix C for a definition).
We make every possible fact argument a small named circle
(node) in the graph.  For each two-argument fact, we draw an arrow
(edge) from the circle for its first argument to the circle for its second
argument, and label the arrow with the predicate name.
So the fact <strong>p(a,b)</strong></em> is represented as an arrow from a circle labeled
"a" to a circle labeled "b", with the arrow itself labeled "p".
If for instance our facts are:
<pre>
a_kind_of(enterprise,ship).
a_kind_of(kennedy,ship).
part_of(enterprise,u_s_navy).
part_of(kennedy,u_s_navy).
part_of(u_s_navy,u_s_government).
a_kind_of(u_s_government,government).
color(ship,gray).
location(enterprise,15n35e).
has(u_s_government,civil_service_system).
</pre>
then our semantic network looks like Figure 2-3.

<p>
<h3>
Getting facts from English descriptions
</h3>

<p>Usually programmers building artificial intelligence programs
don't make up facts themselves.  Instead, they look up facts
in documents and books, or ask
people knowledgeable about the subject ("experts") to tell them what they
need--the process of <em>knowledge acquisition</strong></em>.  But English
and other "natural languages" are less precise than computer languages
(though more flexible), and the programmer must be careful to get
the meanings right.

<p>The sorts of facts we've considered so far are usually often signalled by
the verb "to be" in English (<strong>is</strong></em>, "are", "was", "were", "will be",
"being", and so on).  For instance:
<blockquote>
The Enterprise is a ship.
<br>
A ship is a vehicle.
<br>
The Enterprise is part of the U.S. Navy.
<br>
A ship is gray.
</blockquote>
Here "to be" is used for type predicates (the first and second sentences),
a <strong>part_of</strong></em> relationship predicate (the third sentence), and a property
predicate (the fourth sentence).  Plurals can also be used:
<blockquote>
Ships are gray.
<br>
Ships are vehicles.
</blockquote>

<p>English verbs with narrower meanings can be used too:
<blockquote>
The Enterprise belongs to the U.S. Navy.
<br>
The Enterprise has a hull.
<br>
They color ships gray.
<br>
The Enterprise is located at 15N35E.
</blockquote>
The first two suggest <strong>part_of</strong></em> relationship predicates, and the last two
are property predicates.

<p>
<h3>
Predicates with three or more arguments
</h3>

<p>You can have as many arguments to a predicate as you want if you're
not concerned about easily representing them in a semantic network.
One idea is to include multiple property values in a
single fact, much like adjectives and adverbs modifying a noun
or verb.  So for instance we could put everything we know about
a ship together:
<pre>
ship_info(enterprise,15n35e,1200,16feb85,gray,j_kirk).
</pre>
which we could read as "The Enterprise is a ship that was at 15N25E
at 12 noon on February 16, 1985, and its color is gray, and its captain
is J. Kirk."  To interpret such facts we need to keep a description
somewhere of the properties and their order within the arguments.

<p>These sort of predicates define a <em>relational database</strong></em> of facts.
Much research has studied efficient implementation and manipulation of such
databases.  The information about properties and their order for
each such predicate is called a <em>database schema</strong></em>.

<p>Another important category of predicates with often many
arguments (though they can also have just two) is that representing
results of actions--in mathematical terminology,
<em>functions</strong></em>.  Suppose we want to teach a computer
about arithmetic.  We could use a predicate <strong>sum</strong></em> of three numerical
arguments, which says that the sum of the first two arguments is
the third.  We could give as facts:
<pre>
sum(1,1,2).
sum(1,3,4).
sum(1,4,5).
sum(1,5,6).
sum(2,1,3).
sum(2,2,4).
sum(2,3,5).
sum(2,4,6).
</pre>
And we could do this for lots of different numbers, and different
arithmetic operations.  Of course for this to be useful in general, we
would need very many facts and this would be unwieldy (we will describe
a better way in Chapter 5), but it will suffice to define operations
on any finite set of numbers.

<p>We will use function predicates
frequently.  To avoid confusion, we follow the convention that the last argument
always represents the result of (value returned by) the
function, with the exception noted in the next section | REFERENCE 6|.
.FS
 | REFERENCE 6| If you're familiar with Lisp, be careful to
include the function result as an argument to Prolog predicates.  In Lisp,
a value is always associated with the whole expression,
something you can't do in Prolog.
.FE

<p>Functions can also be nonnumeric.  An example is a function that gives,
for two employees of a company, the name of the lowest-ranking boss over
both of them.  Since artificial intelligence emphasizes nonnumeric
reasoning, you'll see more nonnumeric than numeric functions in this book.

<p>
<h3>
Probabilities
</h3>

<p>We have assumed so far that facts are always completely certain.
In many situations
(as when facts are based on reports by people), facts are only probably true.
Then we will use the mathematical idea of <em>probability</strong></em>,
the expected fraction of the time something is true.  We will put an
approximate probability as an optional last argument to a predicate, after the
previously discussed function result if any.  So for instance
<pre>
color(enterprise,gray,0.8).
</pre>
says that we're 80 percent sure (or sure with probability 0.8)
that the Enterprise is gray.  We'll ignore this topic until Chapter 8.

<p>
<h3>
How many facts do we need?
</h3>

<p>An infinity of facts are true about the world.  How then do we decide
which to tell a computer?  This question has no easy answers.  Generally,
you must decide what you want the computer to do.  Then make sure
to tell the computer in advance every fact that might be relevant to that
behavior.  "Libraries" of useful facts for particular subjects will help.
But the smarter you want the computer to be, the more facts
you must tell it.  The next chapter will discuss the next question,
how to get the computer to do things with facts.

<p>
<h2>
Keywords:
</h2>

<p>
<pre>
<em>knowledge
facts
logic
predicate calculus
Prolog
predicate
predicate expression
arguments
semantics
type predicate
assertion
property predicate
relationship predicate
<strong>part_of<em>
<strong>a_kind_of<em>
semantic network
knowledge acquisition
relational-database predicate
function predicate
probability predicate
</strong></em>
</pre>

<p>
<h2>
Exercises
</h2>

<p>(Note: answers to exercises marked with the code "A" are given at the
back of the book.)

<p>2-1. (A,E)  Which of the following facts is better knowledge representation?
Explain.  ("Better" means less likely to confuse people.)
<pre>
color(enterprise,gray).
size(enterprise,big).
</pre>

<p>2-2. (R,A,E)  Suppose you want to store facts about when and where memos
were sent in
an organization.  Which is the best Prolog format for such facts, and why?
<blockquote>
<strong>(i) &lt;date&gt;(&lt;name&gt;,&lt;author&gt;,&lt;distribution&gt;).</strong></em>
<br>
<strong>(ii) memo(&lt;name&gt;,&lt;date&gt;,&lt;author&gt;,&lt;distribution&gt;).</strong></em>
<br>
<strong>(iii) fact(memo,&lt;name&gt;,&lt;date&gt;,&lt;author&gt;,&lt;distribution&gt;).</strong></em>
</blockquote>

<p>2-3. Draw a semantic network representing the following facts:
<blockquote>
Ships are things.
<br>
Carriers are ships.
<br>
Ships have a position.
<br>
Ships have a crew.
<br>
Carriers have planes.
<br>
Planes are things.
<br>
A crew consists of people.
<br>
People are things.
</blockquote>

<p>2-4. Represent the nonnumeric meaning of the picture in
Figure 2-4 as a set of nonnumeric Prolog facts.  (Hint: describe
the circles and their relationships.)

<p>2-5. (A)  One-argument and two-argument predicates are very common in
Prolog knowledge representation.  Most of the facts you want to put
into computers can be represented with them.  Someone might say
that this shouldn't be surprising, because most operations
in mathematics are either unary (applied to a single thing like the
square root operation or the sine operation), or binary (applied to
two things, like addition and exponentiation).  What's wrong with this
comment?

<p>2-6. (R,A)  Consider the six-argument <strong>ship_info</strong></em> facts in Section 2.9.
To represent them in a semantic network, we need to convert each
to a set of two-argument facts.  Explain how.  Assume that six-argument
facts only record the most recent position of a ship.

<p>2-7. (A,E)   Why might it be a good idea to put falsehoods (statements
false in the world) into a computer?

<p>2-8. Suppose you want to write a program that reasons like Sherlock
Holmes did, about the facts of some crime to decide who is
responsible.  You want to represent in Prolog style the facts you find
about the crime, and the reports of witnesses.  The argument types used for
facts will vary.  But certain arguments must be included in
every fact about the crime--what are they?  And certain arguments must
be included in every fact giving a report from a witness--what are they?

<p>2-9. (E) Why must the representation of these two facts be fundamentally
different?
<blockquote>
Clint is mayor.
<br>
Someone is mayor.
</blockquote>

<p>2-10. (E) Consider the use of the word "boss" in the following facts.  Suppose
you wanted to represent these facts in Prolog.  Would it be a good idea
for any two of these to use the same word "boss" as either a predicate name or
an argument name?
<blockquote>
Mary is boss of Dick.
<br>
Dick and Mary boss their children around.
<br>
"Boss" has four letters.
<br>
A boss has managerial responsibilities.
</blockquote>

<p>2-11. (E) Another way to put facts inside computers is with a restricted
subset of English.  For instance:
<blockquote>
The Enterprise is a ship.
<br>
The Enterprise is part of the US Navy.
<br>
The color of the Enterprise is gray.
<br>
The Enterprise is at 15N25A.
</blockquote>

<p>(a) Discuss the advantages of storing facts this way instead of with
predicate expressions as we have done in the chapter.

<p>(b) Give a disadvantage for efficient use of the facts.

<p>(c) Give a disadvantage for programming errors.

<p>
<p><A HREF="book.html">Go to book index</A>
</body>
</html>
