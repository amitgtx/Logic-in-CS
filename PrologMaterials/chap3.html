<html>
<body>
<hr>
<h2>
Variables and queries
</h2>

<p>We can put facts into a computer.  So what can we do with them?
Well, we want to
<em>reason</strong></em>
about facts and conclude new facts--what's called <em>inference</strong></em>.
For this we'll need the concepts of queries, variables, and backtracking.

<p>
<h3>
Querying the facts
</h3>

<p>One thing we can do with facts in a computer is to
look them up.  This is the usual mode of <em>Prolog interpreters</strong></em>, software
that interprets and executes code written in the Prolog
language | REFERENCE 1|: they wait for us to give them things they can
try to look up.
.FS
 | REFERENCE 1| Most Prolog-understanding software are interpreters like this
and not <em>compilers</strong></em>.  A Prolog interpreter is not an
"artificial intelligence program" but a tool to execute
artificial-intelligence programs written in the Prolog language.
.FE
You're in this <em>query mode</strong></em> when the Prolog interpreter types <strong>?- </strong></em> at
the front of every line.  Query mode is the way
database query languages work, like SQL and QUEL.

<p>To make this clearer, assume these facts (the semantic network example from
Section 2.7) have been entered into a computer running a Prolog interpreter:
<pre>
a_kind_of(enterprise,ship).
a_kind_of(kennedy,ship).
part_of(enterprise,u_s_navy).
part_of(kennedy,u_s_navy).
part_of(u_s_navy,u_s_government).
a_kind_of(u_s_government,government).
color(ship,gray).
location(enterprise,15n35e).
has(u_s_government,civil_service_system).
</pre>
We call such a set of facts known to a Prolog interpreter a <em>Prolog database</strong></em>
or just <em>database</strong></em>.  As we'll
explain shortly, databases can be loaded from files.  The block diagram
in Figure 3-1 summarizes these basics.

<p>Now in query mode we can type
<pre>
part_of(kennedy,u_s_navy).
</pre>
so that what actually shows on the computer terminal will be
<pre>
?- part_of(kennedy,u_s_navy).
</pre>
Note the period; the interpreter will wait (forever if necessary)
until we type it.
Then the interpreter will type in reply the single word <strong>yes</strong></em>
to acknowledge that the fact is in its database.  If we ask instead
<pre>
?- part_of(pequod,u_s_navy).
</pre>
(again the <strong>?- </strong></em> is typed by the interpreter and not us),
the computer will type the single word <strong>no</strong></em>.  So <strong>yes</strong></em> means "I found it" and
<strong>no</strong></em> means "I couldn't find it".  We call a <strong>yes</strong></em> a
query <em>success</strong></em> and <strong>no</strong></em> a query <em>failure</strong></em>.
So to make the computer say <strong>no</strong></em> when a query is <em>false</strong></em>,
the database must include every truth about its subject, for otherwise
<strong>no</strong></em> could mean incomplete data.

<p>
<h3>
Queries with one variable
</h3>

<p>But this isn't too interesting.  A query must give the precise
fact we want to look up, including every argument.  We might instead want
to ask if a <strong>part_of</strong></em> fact has <strong>enterprise</strong></em> as its first argument and
anything at all as its second argument.  We can do this by querying
<pre>
?- part_of(enterprise,X).
</pre>
Read this as "Find me an "X" such that <strong>part_of(enterprise,X)</strong></em> is
true," or simply as "What is the Enterprise part of?"  The Prolog interpreter
will go through its facts in order, trying to match each to the
query.  When it finds one that matches in predicate name and
first argument, it will type "<strong>X=</strong></em>" followed by the fact's second argument,
instead of typing <strong>yes</strong></em>.  Or in technical jargon, it <em>binds</strong></em>
or <em>matches</strong></em> <strong>X</strong></em> to a value and prints it.
So for this query with the previous database, we will get
<pre>
X=u_s_navy
</pre>
or <strong>X</strong></em> is bound to <strong>u_s_navy</strong></em>.

<p><strong>X</strong></em> here is a <em>variable</strong></em>.  Prolog variables have similarities to variables in
other programming languages, but also important differences
we'll encounter as we proceed.  Prolog variables are designated
by a capitalized first letter in a word (followed by other letters and numbers,
either capitalized or uncapitalized), and this is why
in the last chapter we used lower case for other words in Prolog.

<p>Variables can only be arguments in Prolog; they can't appear as
predicate names (though we'll give a way around this limitation in
Chapter 12).  This means Prolog represents only
<em>first-order logic</strong></em>.  First-order logic is sufficient
for nearly all artificial-intelligence applications, so that's no big deal.
First-order logic is a reason we insisted
in Chapter 2 on predicate names more general than their
argument names: variables pay off when they stand for lots of possibilities.

<p>
<h3>
Multi-directional queries
</h3>

<p>A variable can appear anywhere among the arguments to a predicate
expression in a query, with some exceptions to be discussed later.
So we could also query with the previous database
<pre>
?- part_of(X,u_s_navy).
</pre>
and the Prolog interpreter will type back
<pre>
X=enterprise
</pre>
In other words, we can be flexible about which arguments are <em>inputs</strong></em>
(constants) and which are <em>outputs</strong></em> (variables) in a query.  This means
Prolog can answer quite different questions depending on where
we put variables in the query.  This flexibility extends to calls of Prolog
procedures (subroutines and functions) too, as you will see in
Chapter 4, a big difference from most programming languages.

<p>
<h3>
Matching alternatives
</h3>

<p>More than one thing (value) can match (bind) a query variable.  The Prolog
interpreter will find the first, print it out, and stop and wait
If just one
is sufficient, type a carriage return.  But to see the next answer (if any),
type a semicolon ("<strong>;</strong></em>").  We can keep typing semicolons, and it will
keep finding new matches, until it can't find any more and
it must answer <strong>no</strong></em>.  So for our example database if we query
<pre>
?- a_kind_of(X,ship).
</pre>
which means "Find me an X that's a kind of ship," the interpreter will first type
<pre>
X=enterprise
</pre>
and then if we type a semicolon it will type
<pre>
X=kennedy
</pre>
and then if we type a semicolon it will type <strong>no</strong></em>.  The semicolon
prints at the end of the line, so what this will all look like on the
computer terminal will be:
<pre>
?- a_kind_of(X,ship).
X=enterprise;
X=kennedy;
no
</pre>
where we typed the two semicolons and the first line except for the
"<strong>?- </strong></em>", and the interpreter typed the rest.

<p>We can have more than one variable in a query.
If we were to query for our example database
<pre>
?- part_of(X,Y).
</pre>
("What things are part of other things?") and we kept typing semicolons,
we would eventually see on the computer terminal some like this
(some Prolog dialects format this output slightly differently):
<pre>
X=enterprise, Y=u_s_navy;
X=kennedy, Y=u_s_navy;
X=u_s_navy, Y=u_s_government;
no
</pre>
So semicolons find us every combination of bindings of the variables that
satisfies a query.  Since the Prolog interpreter works top to bottom
through the database, the bindings will reflect database order.

<p>
<h3>
Multi-condition queries
</h3>

<p>A Prolog interpreter also lets us specify that several different
conditions must succeed together in a query.
This lets us specify "chains of reasoning", like
those so important to detectives in mystery fiction.

<p>Suppose we wanted to know the gray-color of the Enterprise.  If we type
<pre>
?- color(enterprise,C).
</pre>
we get <strong>no</strong></em> with our example database, because the color fact
is about ships in general and not the Enterprise.  This
problem of information in the "wrong place" happens often
in artificial-intelligence systems.  Instead we can ask if there is
some category or type T that the Enterprise belongs to, such that
everything of type T has color C:
<pre>
?- a_kind_of(enterprise,T), color(T,C).
</pre>
This represents an "and" (<em>conjunction</strong></em>) of two predicate expressions,
both of which must succeed for the whole match to succeed.  It works this way:
we first try to answer the query
<pre>
?- a_kind_of(enterprise,T).
</pre>
Then for that particular <strong>T</strong></em>, we answer the query
<pre>
?- color(T,C).
</pre>
Using our example database, we first match <strong>T</strong></em> to <strong>ship</strong></em> in the first-listed
fact.  We then look for a <strong>color</strong></em> fact in which this <strong>T</strong></em> is the first
argument, and the seventh-listed fact qualifies; we can then match <strong>C</strong></em>
to <strong>gray</strong></em>.  The Prolog interpreter now types out:
<pre>
T=ship, C=gray
</pre>

<p>So commas between predicate expressions in a query line mean
reusing the same values for any same-named variables.
Commas are like a logical "and" since all the subqueries (predicate
expressions) must succeed for the whole query to succeed.
To make commas easier to spot, we'll often put spaces after
them in queries; these spaces are ignored by the interpreter.
(But don't put spaces in predicate expressions.)

<p>As another example, suppose we want to know what the Enterprise is part
of.  We could say
<pre>
?- part_of(enterprise,X).
</pre>
and get <strong>X=u_s_navy</strong></em>, but that's not the only reasonable answer since the
U.S. Navy is part of something else.  So we could say:
<pre>
?- part_of(enterprise,X), part_of(X,Y).
</pre>
and get back <strong>X=u_s_navy, Y=u_s_government</strong></em>.

<p>Logical "or" (<em>disjunction</strong></em>) is represented by a semicolon instead of
a comma.  For instance
<pre>
?- color(enterprise,C); color(ship,C).
</pre>
asks for the color of the Enterprise if any is recorded, otherwise the color
of ships in general.  Parentheses can group which predicate expressions
go with which others in "and"s
and "or"s.  So for instance the two conditions under which something is
part of something else could be compressed into one with:
<pre>
?- part_of(enterprise,X); (part_of(enterprise,Y), part_of(Y,X)).
</pre>
This reads: "Find me an X such that either the Enterprise is part of it,
or the Enterprise is part of some Y that is part of it."  We won't use
these "or" semicolons much, because (1) "and"s occur more often in
applications, (2) they often require parentheses and so are hard to read,
and (3) there is a
better way to get the effect of an "or", to be discussed in the next chapter.

<p>Figure 3-2 should help you keep straight the special symbols
we've used so far, plus previewing a few to come.

<p>
<h3>
Negative predicate expressions
</h3>

<p>So we have "and"s and "or"s.  All we need to complete a Boolean algebra is
a negation or "not".
This is accomplished by the built-in predicate <strong>not</strong></em> whose
one argument is a predicate expression.  (A <em>built-in</strong></em> predicate is one
with special meaning to the interpreter, a meaning not given by facts.)
A <strong>not</strong></em> succeeds whenever querying its argument fails, a fails whenever
querying its argument succeeds.  So the query
<pre>
?- not(color(enterprise,green)).
</pre>
will succeed whenever there's no fact that the color of the
Enterprise is green, and fail when there is such a fact.  We'll extend
the term "predicate expression" to include such <strong>not</strong></em> expressions too.

<p>How will the Prolog interpreter ever be sure something is
<em>not</strong></em>
true?  Strictly speaking, it can't, since facts that directly say something is
false are not permitted in Prolog (Chapter 14 discusses this further).
So <strong>not</strong></em> is defined to mean the interpreter couldn't find a fact in
its database--<em>negation-by-failure</strong></em> or <em>the closed-world assumption</strong></em>.
Yet this is a curious and awkward interpretation of "not", not
what we usually mean by the word in English.  So we must be careful
with <strong>not</strong></em> in Prolog.  One big problem is that we can't, with a few exceptions,
put unbound variables within a <strong>not</strong></em>.  So this query won't work:
<pre>
?- not(color(X,gray)), a_kind_of(X,ship).
</pre>
(This asks for a ship <strong>X</strong></em> that isn't gray.)  Instead we must reverse
the order of the two things:
<pre>
?- a_kind_of(X,ship), not(color(X,gray)).
</pre>

<p>
<h3>
Some query examples
</h3>

<p>Questions in English about a database often map directly into Prolog
queries.  Words like <strong>is</strong></em>, "are", "does", and "did" at the beginning
of a question suggest queries without variables (yes/no queries).
Words like "what", "which", "who",
"where", "when", and "how" suggest variables.

<p>Here are some examples.  We assume the meanings of the <strong>part_of</strong></em>,
<strong>color</strong></em>, <strong>a_kind_of</strong></em>, etc. predicates we've been assuming all along.
(These queries print out additional variable values than those desired;
Chapter 4 will explain how to prevent this.)

<p>1. What things are part of gray things?
<pre>
?- part_of(X,Y), color(Y,gray).
</pre>

<p>2. What things are part of parts of other things?
<pre>
?- part_of(A,B), part_of(B,C).
</pre>

<p>3. What things are gray or blue?
<pre>
?- color(T,gray); color(T,blue).
</pre>

<p>4. What isn't an example of a gray thing?  (<strong>Example</strong></em> suggests the
reverse of the <strong>a_kind_of</strong></em> relationship.)
<pre>
?- a_kind_of(E,T), not(color(T,gray)).
</pre>

<p>5. What is the Enterprise, either directly or
through one level of indirection?
<pre>
?- a_kind_of(enterprise,J); (a_kind_of(enterprise,K), a_kind_of(K,J)).
</pre>

<p>6. What things of which the Enterprise is part, are themselves part of
something that has a civil service system?
<pre>
?- part_of(enterprise,U), part_of(U,V), has(V,civil_service_system).
</pre>

<p>
<h3>
Loading a database
</h3>

<p>How do we load a database of facts into a Prolog interpreter in the
first place?  This varies between implementations of Prolog interpreters,
but usually we must first enter the facts we want
into a text file, using an editor program.  We
exit the editor and start up the Prolog interpreter.  We then query a special
<em>built-in</strong></em> loading predicate, called <strong>consult</strong></em> in this book.
This <strong>consult</strong></em> is not something we must give facts for, but an
internal Prolog name like <strong>not</strong></em>; it
takes one argument, the name of a file to load
into the Prolog interpreter's internal memory (database).
From then on, the facts in that file will be used to answer queries.

<p>For instance, suppose we use the editor to create a file called
"test", containing:
<pre>
boss(harry).
employee(tom).
employee(dick).
</pre>
We can start the Prolog interpreter, type the query
<pre>
?- consult(test).
</pre>
and then type the query
<pre>
?- employee(X).
</pre>
and get
<pre>
X=tom
</pre>
from the first fact in the file that matches.

<p>We can load more than one file into the Prolog interpreter, if several
files contain useful facts.  Just query <strong>consult</strong></em> again.  New facts
are put after the old facts, so you can get answers in a different
order if you load the same files in a different order.

<p>
<h3>
Backtracking
</h3>

<p>Let's consider in more detail how the Prolog interpreter answers complicated
queries.  To make this easier, consider for now queries with only
commas ("and"s), no semicolons ("or"s) or <strong>not</strong></em>s.

<p>Predicate expressions "and"ed in a query are first taken left to right.
That is, the leftmost expression is tried first, then
the second expression from the left (using whatever variable matches
were found for the first) and so on.  So predicate expressions in a
query are initially done in order, like lines of a program in a conventional
language like Pascal.

<p>But suppose that a predicate expression fails--that is, no fact matching
it can be found.  If the expression has variables that were
bound earlier in the query
line, the fault may just be in the bindings.  So the interpreter automatically
<em>backtracks</strong></em> (goes back to the immediately previous expression in the query)
and tries to find a different fact match.  If it cannot, then <em>that</strong></em>
predicate expression fails and the interpreter backtracks to the previous one,
and so on.

<p>Anytime the Prolog interpreter cannot
find another matching for the leftmost expression in a query, then there's
no way the query could be satisfied; it types out the word <strong>no</strong></em> and stops.
Anytime on backtracking it can find a new matching for some predicate
expression, it resumes moving right from there as it did originally.

<p>The purpose of backtracking is to give "second chances" to a query, by
revising earlier decisions.   Backtracking is very important in artificial
intelligence, because many artificial-intelligence methods use
intelligent guessing and following of hunches.  Guesses may be wrong, and
backtracking is a good way to recover then.

<p>Here's an example:
<pre>
?- part_of(X,Y), has(Y,civil_service_system).
</pre>
which asks for an <strong>X</strong></em> that is part of some <strong>Y</strong></em> that has a civil service system.
Assume the standard database example of this chapter.  Then
the only facts that will help with this query (the
only facts with predicate names <strong>part_of</strong></em> and <strong>has</strong></em>) are:
<pre>
part_of(enterprise,u_s_navy).
part_of(kennedy,u_s_navy).
part_of(u_s_navy,u_s_government).
has(u_s_government,civil_service_system).
</pre>

<p>Here in detail is what the Prolog interpreter does to answer this query:
<blockquote>
1. It takes the first predicate expression in the query, and matches <strong>X</strong></em> to
<strong>enterprise</strong></em>, and <strong>Y</strong></em> to <strong>u_s_navy</strong></em>.  It stores the information that it has
chosen the first fact to match the first expression.

<p>2. It then moves to the second predicate expression, and tries to answer the
<em>subquery</strong></em>
<pre>
?- has(u_s_navy,civil_service_system).
</pre>
That is, it "substitutes" in the value bound to variable <strong>Y</strong></em>.
But the subquery fails since there's no such fact.

<p>3. So it must backtrack, or return to the first predicate expression in the
query.  From its stored information, it knows it chose the first <strong>part_of</strong></em>
fact last time, so now it tries the second, binding <strong>X</strong></em> to <strong>kennedy</strong></em>
and <strong>Y</strong></em> to <strong>u_s_navy</strong></em>.  It stores the information about what it chose.

<p>4. It then tries to answer the subquery
<pre>
?- has(u_s_navy,civil_service_system).
</pre>
This is the same query it did in step 2, but the interpreter is stupid and
doesn't remember (Chapter 6 will explain how to force it to remember),
so it checks the facts and fails to find anything again.  The subquery fails.

<p>5. So it backtracks again, to the first predicate expression in
the query.  It chose the second fact last time, so it now chooses the
third (and last) <strong>part_of</strong></em> fact.  So <strong>X</strong></em> is bound to <strong>u_s_navy</strong></em>
and <strong>Y</strong></em> is bound to <strong>u_s_government</strong></em>.

<p>6. The second expression is considered with the new binding for <strong>Y</strong></em>,
and the interpreter tries to answer the subquery
<pre>
?- has(u_s_government,civil_service_system).
</pre>
And this succeeds because it's the fourth fact.

<p>7. So both predicate expressions in the query succeed, and the whole query
succeeds.  The interpreter prints out the bindings that it found:
<pre>
X=u_s_navy, Y=u_s_government
</pre>
</blockquote>

<p>Notice that the interpreter wouldn't have had to backtrack if we just reversed
the order of the query ("and" is commutative--see Appendix A):
<pre>
?- has(Y,civil_service_system), part_of(X,Y).
</pre>
because only one fact can match the <strong>has</strong></em> predicate expression.
But that requires analyzing the facts in advance, and probably won't
be true for a complete database for an application.

<p>The automatic backtracking of the Prolog interpreter has both advantages
and disadvantages.  A big advantage is that combinatorial problems are
easier to specify than with most computer languages, because the interpreter
does more work for you.
It also means that Prolog is a more flexible language than most: if you
refer to an unbound variable in Pascal, Ada, PL/I, or Fortran, you
get an error message and the program stops.  The disadvantages are
that Prolog programs run slower than those of other languages, and they're
sometimes harder to understand and debug, because the language tries
to do more.

<p>
<h3>
A harder backtracking example: superbosses
</h3>

<p>Here is another backtracking example.  It's trickier than the last because
two predicate expressions both have alternatives.  Furthermore, the same predicate
name is used twice, and we have to distinguish the alternatives for each use.

<p>Suppose we have facts about employees in an organization, represented with
a two-argument predicate <strong>boss</strong></em>.  Its first argument
a boss, and its second argument is
an employee of that boss.  Take the following example database:
<pre>
boss(dick,harry).
boss(tom,dick).
boss(ann,mary).
boss(mary,harry).
</pre>
Suppose we want find "superbosses", people who are bosses of
bosses.  That is, those X that are a boss of some Y
while at the same time Y is a boss of some Z.  We can issue the query
<pre>
?- boss(X,Y), boss(Y,Z).
</pre>
and every match the interpreter finds for variable <strong>X</strong></em> will be a superboss.
(Matches for <strong>Y</strong></em> and <strong>Z</strong></em> will also be found, but <strong>X</strong></em> is all that we want, according
to the way we stated the problem.)

<p>Let's trace query execution (summarized in Figure 3-3).
As usual, assume facts are placed in the Prolog database in the order listed.
<blockquote>
1. The first predicate expression in the query will match the first
fact in the database, with <strong>X=dick</strong></em> and <strong>Y=harry</strong></em>.

<p>2. Moving to the second predicate expression in the query, the
interpreter searches for a <strong>boss</strong></em> fact
with <strong>harry</strong></em> as its first argument.  But there's no such
fact in the database, so the second expression in the query fails.

<p>3. So the interpreter
backtracks, returning to the first expression to make another
choice.  Last time it used the first fact in the database, so this time
it uses the second fact and sets <strong>X=tom</strong></em> and <strong>Y=dick</strong></em>.

<p>4. Things proceed just as if these matchings happened originally.  The
interpreter goes to the second predicate expression, and searches for a
<strong>boss</strong></em> fact where <strong>dick</strong></em> is the first argument.  And yes, there is such
a fact, the first fact in the database.

<p>5. So <strong>Z=harry</strong></em>, and since we're at the end of the query, the query
succeeds.  Therefore Tom is a superboss.  The interpreter types out
<strong>X=tom, Y=dick, Z=harry</strong></em>.
</blockquote>

<p>Now we can explain better what typing a semicolon does after the Prolog
interpreter types out a query answer (not to be confused with a semicolon
in a
<em>query:</strong></em>
it forces failure and
backtracking.  For instance, suppose after that answer <strong>X=tom</strong></em>
we type a semicolon instead of a carriage return.  What happens
now is summarized in Figure 3-4, together with the previous events.
<blockquote>
6. The interpreter will go back to what it just finished, the second
expression of the query, and try to find a different match.

<p>7. The old match for the second query expression was from the first fact,
so now it examines the second, third, and fourth facts in order.
Unfortunately, none have <strong>dick</strong></em> as their first argument, so the
expression fails.

<p>8. So the interpreter must return to the first predicate expression yet
again.  The first and second facts have been tried, so it uses the third
fact and sets <strong>X=ann</strong></em> and <strong>Y=mary</strong></em>.

<p>9. It resumes normal left-to-right processing and tries to find a match
for the second query expression, starting at the top of
the list of facts.  (Each time it approaches a query predicate expression
from the left, it starts at the top of the facts.)  This means finding a
fact where <strong>mary</strong></em> is the first argument, and indeed the fourth fact qualifies.

<p>10. So <strong>Z=harry</strong></em>, and the entire query succeeds when <strong>X=ann</strong></em>, meaning that
Ann is a superboss.  The interpreter types out <strong>X=ann, Y=mary, Z=harry</strong></em>.
</blockquote>

<p>
<h3>
Backtracking with "not"s
</h3>

<p>Negated predicate expressions (expressions with a <strong>not</strong></em>) are easy
with backtracking.  Since they can't bind variables to succeed,
they can be skipped in backtracking.  For instance, we
could add another expression to our superboss query to insist that
the superboss not be the boss of Dick:
<pre>
?- boss(X,Y), not(boss(X,dick)), boss(Y,Z).
</pre>
Then when the interpreter executes the new query (see Figure 3-5):
<blockquote>
1. The first predicate expression matches the first fact in the database
as before, setting <strong>X=dick</strong></em> and <strong>Y=harry</strong></em>.

<p>2. This binding of <strong>X</strong></em> satisfies the second condition, the <strong>not</strong></em> (Dick isn't
his own boss).

<p>3. For the third expression, there's no fact with <strong>harry</strong></em>
as its first argument, so it fails.  The interpreter backtracks
to the immediately previous (second) expression.

<p>4. But the second expression is a <strong>not</strong></em>, and <strong>not</strong></em>s always
fail on backtracking, so the interpreter returns to the first
expression and matches <strong>X=tom</strong></em> and <strong>Y=dick</strong></em>.

<p>5. But this <strong>X</strong></em> now makes the second expression fail--there is a
fact that Tom is the boss of Dick.

<p>6. The interpreter returns to the first predicate
expression and takes the next matching from the database,
<strong>X=ann</strong></em> and <strong>Y=mary</strong></em>.

<p>7. This <strong>X</strong></em> succeeds with the second expression since Ann isn't
the boss of Dick.

<p>8. The <strong>Y</strong></em> match succeeds with the third expression if <strong>Z=harry</strong></em>.
So the interpreter reports that <strong>X=ann, Y=mary, Z=harry</strong></em>.
</blockquote>

<p>Notice the backtracking works differently if we rearrange the query
into this equivalent form:
<pre>
?- boss(X,Y), boss(Y,Z), not(boss(X,dick)).
</pre>
This is processed very much like the original two-expression superboss query,
except that the <strong>not</strong></em> expression forces failure instead of success
for <strong>X=tom</strong></em>;
we got the same effect by typing a semicolon after the first answer to
the query in the last section.
But the query won't work right if we reorder it as
<pre>
?- not(boss(X,dick)), boss(X,Y), boss(Y,Z).
</pre>
because now a <strong>not</strong></em> with an unbound variable is first, violating the
guideline of Section 3.6.

<p>
<h3>
The generate-and-test scheme
</h3>

<p>When a variable occurs more than once in a Prolog query, the Prolog interpreter
chooses a value (binding) at the first occurrence, and then uses it in all
other occurrences.  So processing of the predicate expression containing the
first occurrence "generates" a value, which is "tested" by the predicate
expressions containing later occurrences.  This idea is often used in
artificial intelligence, and it's called the <em>generate-and-test</strong></em> scheme
or paradigm.  Often the generating predicate expressions define
the types of the variables, so their predicates are type predicates
(Section 2.2).

<p>Generate-and-test is a good way to attack problems for which we don't know
any particularly good way to proceed.  We generate potential
solutions, and apply a series of tests to check for a true
solution.  This works well when it's hard to reason backward about
a problem (from a statement of the problem to a solution), but
it's easy to reason forward from a guess to a solution (or verify a
proposed solution).
An example is cryptography (decoding ciphers): an approach is to guess
possible coding (encryption) methods, and see if any of them gives
coded text resembling a coded message.  Many other interesting problems
work well for generate-and-test.  But problems with well-defined
solution methods, like many mathematical problems, aren't suitable for it.

<p>
<h3>
Backtracking with "or"s (*)
</h3>

<p>Semicolons in queries ("or"s) are tricky for backtracking.
We'll mostly ignore them in this book because, as we say, there's a
better way to get their effect; but for the record, here's what happens.
When a predicate expression before a semicolon succeeds, all the other
expressions to the right that are "or"ed with it can be
skipped.  When such an expression fails, the next term to the right
should be tried.  If there aren't any more, the whole "or" should fail,
which usually means backtracking to the left.  So while backtracking with
"and"s always goes left, backtracking with "or"s sometimes goes left and
sometimes goes right.

<p>
<h3>
Implementation of backtracking
</h3>

<p>Implementing backtracking requires allocation of a pointer (Appendix C
defines pointers) for every predicate expression in a query, a pointer
to where in the database the interpreter last found a match for a predicate
expression.  So Prolog is more complicated to implement than conventional
higher-level languages like Pascal that only need extra storage in the form
of a stack for procedure calls (Appendix C defines stacks too).
Prolog needs a stack for this purpose too, as you'll see in Chapter 4.

<p>Queries don't necessarily require inspection of facts in the database in
sequence (<em>sequential search</strong></em>).  All Prolog
interpreters <em>index</strong></em> facts in some way, usually at least by predicate
name.  This means keeping lists of facts with the same predicate name,
together with their addresses.
So when the interpreter sees an <strong>a_kind_of</strong></em> predicate
in a query, it need only search through the <strong>a_kind_of</strong></em> facts pointed to
in the <strong>a_kind_of</strong></em> index list for a match.  Figure 3-6
gives an example of a database and its index.  More selective indexing (not
standard in most Prolog dialects, though) can examine the arguments too.

<p>Indexing by predicate name means
that Prolog facts can go in many different orders and still provide
exactly the same behavior.  For instance, the facts in Figure 3-6
<pre>
a_kind_of(enterprise,ship).
a_kind_of(kennedy,ship).
part_of(enterprise,u_s_navy).
part_of(kennedy,u_s_navy).
part_of(u_s_navy,u_s_government).
</pre>
can be rearranged as
<pre>
part_of(enterprise,u_s_navy).
a_kind_of(enterprise,ship).
part_of(kennedy,u_s_navy).
a_kind_of(kennedy,ship).
part_of(u_s_navy,u_s_government).
</pre>
and all queries will give the same answers in
the same order, as they will for
<pre>
part_of(enterprise,u_s_navy).
part_of(kennedy,u_s_navy).
part_of(u_s_navy,u_s_government).
a_kind_of(enterprise,ship).
a_kind_of(kennedy,ship).
</pre>
But this is only because the three <strong>part_of</strong></em> facts maintain their order
and the two <strong>a_kind_of</strong></em> facts maintain their order.  The following database
will give answers in a different order than the preceding, though it
gives the same answers:
<pre>
a_kind_of(kennedy,ship).
part_of(u_s_navy,u_s_government).
part_of(enterprise,u_s_navy).
a_kind_of(enterprise,ship).
part_of(kennedy,u_s_navy).
</pre>

<p>The speed of query answering depends on how many facts
are indexed for each predicate in a query; the more facts, the
slower the queries.  Queries will also be slower when variables
appear multiple times in the query and there is no argument indexing.
This situation, called a <em>join</strong></em> in
database systems, requires embedded iterative loops, and loops
can take a lot of time.  With joins, possibilities literally multiply.
For our previous example
<pre>
?- a_kind_of(enterprise,X), color(X,C).
</pre>
if there are 100 <strong>a_kind_of</strong></em> facts and 50 <strong>color</strong></em> facts, 50,000
combinations must be tried to find all possible <strong>X</strong></em> and <strong>C</strong></em> pairs, as when we
type a semicolon repeatedly or when there are no such <strong>X</strong></em> and <strong>C</strong></em>.

<p>
<h3>
About long examples
</h3>

<p>We've studied several long examples in this chapter.  Are
all the examples of artificial intelligence like this?  Yes, unfortunately.
Artificial intelligence is a set of techniques for managing complexity, and
you can only see its advantages in at least moderately complex problems.

<p>This disturbs some students.  They feel that since they can't get all of
a long example into their heads at once, they can't really understand
what's going on.  One reply is to think of programming languages.
There's a lot of activity behind the scenes that the programmer
isn't usually aware of--parsing, storage management, symbol tables, stacks,
type checking, register allocation, and optimization.  But you don't
need to know this to program.  The complexity of
artificial-intelligence examples comes from the need to explain, at least
initially, similar behind-the-scenes details.  Once you understand what details
are necessary, you can ignore them as you program.

<p>Most artificial-intelligence programs and systems do provide additional help
for understanding complex program activities
in the form of <em>explanation</strong></em> facilities that
summarize and answer questions about reasoning activity.  These facilities
provide program tracing, and answer questions like "Why did you conclude
boss(tom,dick)?" and "Why didn't you conclude boss(dick,tom)?".
More on this in Section 15.8.

<p>
<h2>
Keywords:
</h2>

<p>
<pre>
<em>inference
Prolog database
Prolog interpreter
query
success
failure
variable
binding variables
first-order logic
inputs
outputs
match
matching alternatives
database order
conjunction
match
disjunction
negation
<strong>not<em>
built-in predicates
closed-world assumption
<strong>consult<em>
backtracking
failure
indexing
generate-and-test</strong></em>
</pre>

<p>
<h2>
Exercises
</h2>

<p>3-1. (A) Good programming style in Prolog doesn't allow the argument to
a <strong>not</strong></em> to be more than one predicate expression, and doesn't allow composite queries
(queries not just a single predicate expression) "or"d together.

<p>(a) Using good programming style, write a Prolog query that is true if the
"nor" of predicate expressions s <strong>a</strong></em> and <strong>b</strong></em>
(both of no arguments) is true.  ("Nor" means the opposite of an "or").

<p>(b) Using good programming style, write a Prolog query that is true
if the "exclusive or" of predicate expressions <strong>a</strong></em> and <strong>b</strong></em> is true.
("Exclusive or" means either is true but not both).

<p>3-2. (R,A)  Suppose you have the following Prolog database:
<pre>
incumbent(csprofessor,davis).
incumbent(csprofessor,rowe).
incumbent(csprofessor,wu).
incumbent(csprofessor,zyda).
incumbent(cschairman,lum).
incumbent(dean_ips,marshall).
incumbent(provost,shrady).
incumbent(superintendent,shumaker).
incumbent(director_milops,bley).
bossed_by(csprofessor,cschairman).
bossed_by(cschairman,dean_ips).
bossed_by(orchairman,dean_ips).
bossed_by(dean_ips,provost).
bossed_by(provost,superintendent).
bossed_by(director_milops,superintendent).
</pre>

<p>(a) The <strong>incumbent</strong></em> predicate means that the person that is its second
argument has the job description that is its first argument; the <strong>bossed_by</strong></em>
predicate means that the boss of the first argument is the second argument.
Paraphrase each of the following Prolog queries in English.
<pre>
?- bossed_by(csprofessor,X), bossed_by(X,Y).
?- bossed_by(X,Y), incumbent(X,rowe), incumbent(Y,Z).
?- incumbent(dean_ip,X); incumbent(dean_ips,X).
?- incumbent(J,P), (bossed_by(J,provost); bossed_by(J,dean_ips)).
?- bossed_by(P,superintendent), not(incumbent(P,shrady)).
</pre>

<p>(b) Without using a computer, what will be the first answer found by a
Prolog interpreter with the preceding database and with each query given?

<p>3-3. Suppose two queries each represent an "and" of a number of predicate
expressions.
Suppose the expressions of query 1 are a subset of the expressions in query 2.
How do the answers to query 1 relate to the answers to query 2?

<p>3-4. The words "the" and "a" mean different things in English.  What important
feature of Prolog querying does the difference between them demonstrate
in the following sentences?
<blockquote>
Find a memo we sent headquarters last week.  The memo reported
on a board meeting last October 10.  The board meeting was noisy, and this
is mentioned in the memo.
</blockquote>

<p>3-5. (A)  Suppose in your Prolog database you have N one-argument facts for the
predicate name <strong>p</strong></em> and M one-argument facts for the predicate name <strong>q</strong></em>.

<p>(a) What is the maximum number of answers, not counting <strong>no</strong></em>, that you will
get to the query
<pre>
?- p(X), q(Y).
</pre>

<p>(b) How many total times will the Prolog interpreter backtrack from <strong>q</strong></em>
to <strong>p</strong></em> for the situation in part (a), before it types <strong>no</strong></em>?

<p>(c) What is the minimum number of answers to the query in part (a)?

<p>(d) What is the maximum number of answers, not counting <strong>no</strong></em>, you will get to
the query
<pre>
?- p(X), q(X).
</pre>

<p>(e) How many total times will the Prolog interpreter backtrack from
<strong>q</strong></em> to <strong>p</strong></em> for the situation in part (d), before it types <strong>no</strong></em>?

<p>(f) What is the minimum number of answers to the query in part (d)?

<p>3-6. (R,A)  Suppose we keep in a Prolog database information about grades on
two tests in a course.

<p>(a) Suppose we ask if Joe got an A on test 1 and the Prolog interpreter
says <strong>yes</strong></em>.  Suppose
we then ask if Joe got an A on test 2 and it says <strong>yes</strong></em>.  It seems fair
to summarize this by saying Joe got A's on both tests 1 and 2.  Now suppose
we ask if someone got an A on test 1 and the interpreter says <strong>yes</strong></em>.  We ask if
someone got an A on test 2 and it says <strong>yes</strong></em>.  It is unfair now to
conclude that someone got an A on both test 1 and test 2.  How is this
situation different?  How does this illustrate an important feature of
Prolog querying?

<p>(b) Suppose the database consists of facts of the form:
<pre>
grade(&lt;person&gt;,&lt;test-number&gt;,&lt;grade&gt;).
</pre>
Write a query that establishes if everyone in the class got an A on test 1,
without using an "or" (semicolon).  (Hint: Use the exact opposite.)

<p>(c) Suppose you ask if everyone in the class got an A on test 1 and the
Prolog interpreter says <strong>yes</strong></em>.  Suppose you then ask if everyone in the
class got an A on test 2 and it says <strong>yes</strong></em>.  Can you conclude that everyone
in the class got both an A on test 1 and an A on test 2?  Why?  Assume this
is a real class at a real college or university.

<p>3-7. Here's a summary of the current situation on the fictitious
television soap opera <em>Edge of Boredom:</strong></em>
<blockquote>
Jason and Phoebe are married, but Phoebe is in love with Perry.  Perry
doesn't love her because he is still married to Stacey, but Zack is
romantically inclined toward Phoebe. He's in competition with Lane, who
also loves Phoebe despite being married to Eulalie, whom Jason is feeling
romantic about.
</blockquote>

<p>(a) Represent the basic meaning of these statements by facts using only
two different predicate names.  Notice that if X is married to Y, Y is
married to X.

<p>(b) A marriage is on the rocks if both its participants are in love with
other people and not with each other.  Which people are in
marriages that are on the rocks?  Show
the necessary Prolog query and its result.

<p>(c) A person is jealous when a person they love is loved by a third person,
or a person is jealous when married to someone loved by a
third person.  Which people are jealous?  Show the necessary Prolog
query and its result.

<p>3-8.(a) Consider the query
<pre>
?- a(X,Y), b(X,Y).
</pre>
with the database
<pre>
a(1,1).
a(2,1).
a(3,2).
a(4,4).
b(1,2).
b(1,3).
b(2,3).
b(3,2).
b(4,4).
</pre>
Without using a computer, what are all the answers that you will get to the
query, in order (as you keep typing semicolons)?

<p>(b) Without using a computer, what does this query print out (as you keep
typing semicolons)?
<pre>
?- a(X,Y), b(X,Y), a(Y,Y).
</pre>

<p>3-9. (A)  Consider this Prolog query:
<pre>
?- r(X,Y), s(Y,Z), not(r(Y,X)), not(s(Y,Y)).
</pre>
with this database:
<pre>
r(a,b).
r(a,c).
r(b,a).
r(a,d).
s(b,c).
s(b,d).
s(c,d).
s(c,c).
s(d,e).
</pre>

<p>(a) Without using a computer, what is the first answer found to the query?
Hint: you don't have to do it Prolog's way.

<p>(b) Without using a computer, how many times does a Prolog interpreter
backtrack from the third to the second predicate expression to get this first answer?

<p>3-10. Consider this Prolog database:
<pre>
u(a,b).
u(b,b).
u(c,d).
u(c,a).
u(d,a).
u(d,c).
</pre>
Now consider this Prolog query, without actually using a computer:
<pre>
?- u(X,Y), u(Y,Z), not(u(X,Z)).
</pre>

<p>(a) How many times will a Prolog interpreter backtrack to the first query
predicate expression <strong>u(X,Y)</strong></em> to find the first answer to this query?

<p>(b) How many times will a Prolog interpreter backtrack to the second query
predicate expression <strong>u(Y,Z)</strong></em> to find the first answer to this query?

<p>(c) How many times will a Prolog interpreter backtrack to the third query
predicate expression <strong>not(u(X,Z))</strong></em> to find the first answer to this query?

<p>(d) How many further times will a Prolog interpreter backtrack to the
first query predicate expression <strong>u(X,Y)</strong></em> to find the second answer to this query?

<p>(e) How many further times will a Prolog interpreter backtrack to the
second query predicate expression <strong>u(Y,Z)</strong></em> to find the second answer to this query?

<p>3-11. (H) Design a good set of predicates for the following data about an
organization  and its employees.  Assume you have to do this in Prolog.
Try to be efficient: avoid duplicate data, empty data, and too many linking
arguments, while keeping data access reasonably fast.

<p>Assume we have an organization with departments, subdepartments,
and projects.  A subdepartment can belong to only one department,
but a project can belong to more than one subdepartment or
department (but most of the time only one).  Employees belong
to one subdepartment and one or more projects.  Employees have
a name, social security number, date of birth, address, and
a list of successfully completed projects that they
participated in since they joined the organization.  Employees
also are characterized by Personnel by "job skills"
they have from a rough list (e.g. "can type", "has truck license",
"experience in writing").  Projects have a name, code, starting
date, projected or actual completion date, and the room number
for the office of each employee on the project.  Employees have
only one office, but there may be more than one employee in the
same office.

<p>Design these predicates to answer these questions easily:
<blockquote>
--Give the name, department, and office number for each employee on
project 93521.
<br>
--Give the name, department, and office number for each employee on
projects started last year.
<br>
--Give the people in department 43 who have typing skills.
</blockquote>

<p>3-12. Questions in English have subtleties that are sometimes hard
to translate into Prolog queries.  This became obvious in building
the first <em>natural language front ends</strong></em> to databases, computer programs
that tried to answer, in English, questions about the database contents.
Here are illustrations of two bugs discovered in those early programs.  Try
to explain what a program like a Prolog interpreter is missing when it makes
such errors.  (Brackets give our explanatory comments.)

<p>(a)
<blockquote>
Person: Can you tell me the commander of the Enterprise and his rank?
<br>
Computer: Yes. [That's all it types in response.]
</blockquote>

<p>(b)
<blockquote>
Person: Who commands the Pequod?
<br>
Computer: Nobody.  [That's strange, because every ship must have a commander.]
<br>
Person: Where is the Pequod currently?
<br>
Computer: Nowhere. [Strange ship this Pequod.]
<br>
Person: Does the Pequod exist?
<br>
Computer: No. [So that's the reason.]
</blockquote>

<p>
<p><A HREF="book.html">Go to book index</A>
</body>
</html>
