<html>
<body>
<hr>
<h2>
Implementation of rule-based systems
</h2>

<p>Let's examine how different control structures for rule-based systems can be
implemented in Prolog.  We'll cover backward chaining, rule-cycle hybrid
chaining, forward chaining, input and output routines, meta-rules,
and decision lattices.  This will mean a lot of details; the last section of
this chapter brings together the key Prolog code.

<p>
<h3>
Implementing backward chaining
</h3>

<p>Though Prolog is designed for backward chaining, there are many
details for an implementer of a backward-chaining rule-based system
to worry about when using Prolog, especially when the rule-based system
is large. The traffic lights program
in Section 4.11 was simple because traffic laws are
<em>supposed</strong></em>
to be simple, so even people unenlightened enough never to have taken
an artificial intelligence course can understand them.  Many rule-based
expert systems can't be so nice, like those that diagnose and fix hard
problems.  Such rule-based systems are often called
<em>expert systems</strong></em>, because they automate the role of human experts.
We'll introduce some general-purpose programming aids for expert systems
in this chapter.

<p>The goal of most expert systems is to reach a diagnosis, which we'll assume
is obtained by typing the query
<pre>
?- diagnosis(X).
</pre>
So what is X?  It should describe a situation.
We could connect words
with underscores as before, but there's an alternative: we can put single
quotation marks (apostrophes) around a string of words to force
treatment of it as a unit.  That is, a <em>character string</strong></em>.
An advantage of character strings is that they can start with capital letters
and contain periods and commas, while words can't.

<p>Here are some example diagnosis rules for an expert system:
<pre>
diagnosis('fuse blown') :- doesnt_work, all_lights_out.
diagnosis('fuse blown') :- noise(pop).
diagnosis('break in cord') :- doesnt_work, cord_frayed.
</pre>
Of course we must define those right-side
predicates.

<p>
<h3>
Implementing virtual facts in caching
</h3>

<p>One problem is those rules require advance entry of facts (often,
many facts) so that rule right sides can work
properly.  As we mentioned in the last chapter, virtual facts (facts
demanded only when needed) are a simple improvement.
A good way to get them is to define a function predicate <strong>ask</strong></em> of two bound
arguments.  The first argument is an input, a string containing question
text to be typed out
on the terminal, and the second argument is an output, a variable to be bound
to the question's answer that the user types.
<pre>
ask(Q,A) :- write(Q), write('?'), read(A), nl.
</pre>
Here <strong>write</strong></em>, <strong>read</strong></em>, and <strong>nl</strong></em> are Prolog predicates built-in in most
implementations (see Appendix D); <strong>write</strong></em> prints its argument on the
terminal, <strong>read</strong></em> reads something typed by the user
and binds that something to the variable that is the <strong>read</strong></em>'s argument, and <strong>nl</strong></em>
sends a carriage return to the terminal.

<p>Now we never want to ask a user the same question twice; we should
cache answers so we can reuse them.  It's easy to add this feature to the <strong>ask</strong></em> predicate.  We
just use the <strong>asserta</strong></em> built-in predicate introduced in
Section 6.1, which takes a fact as argument and adds it to the
Prolog database.  Using it, conclusions can be added to the database as they are discovered.
We can stick the <strong>asserta</strong></em> at the end of the definition of the <strong>ask</strong></em> predicate:
<pre>
ask(Q,A) :- write(Q), write('?'), read(A), nl, asserta(ask(Q,A)).
</pre>
Then if the same question is asked again, the fact will be used to answer it
instead of this rule.  This works because facts put in the
database with <strong>asserta</strong></em> are put in front of all other facts and rules
with the same first predicate name.
Here's an example of the use of <strong>ask</strong></em>:
<pre>
diagnosis('fuse blown') :- ask('Does the device work at all',no),
  ask(Are the lights in the house off',yes).
</pre>
This says to diagnose that the fuse is blown if (1) the user
answers <strong>no</strong></em> when asked whether the device works at all, and (2) the user
answers <strong>yes</strong></em> when asked whether all the lights in the house are off.

<p>You should carefully phrase the questions to be issued by a
rule-based system.  In particular, avoid pronouns and other
indirect references to things, since rules and questions may be invoked
in hard-to-predict orders.  Generally, though there are exceptions, phrase
questions so a <strong>yes</strong></em> answer means unusual things are going on, while a
<strong>no</strong></em> means things are normal.  For instance, after "Are the lights in
the house off?", don't ask "Is the fuse OK?" but "Is the fuse blown?".
And be consistent in phrasing questions.
After that question "Are the lights in the house off?",
ask "Does the fuse look blown?" in preference to than "The fuse looks blown
doesn't it?", to maintain the same verb-noun-adjective order.

<p>
<h3>
Input coding
</h3>

<p>We could implement a big expert system this way, with diagnosis
rules having <strong>ask</strong></em> predicates on their right sides.  But this can
require unnecessary code repetition.  So two important coding tricks
are used in large rule-based systems: coding of input (answers)
and coding of output (questions and diagnoses).

<p>Input coding groups user answers into categories.  An important
case is questions with only <strong>yes</strong></em> or <strong>no</strong></em> answers; expert systems often
to rely on them for simplicity.  We can define two
new predicates <strong>affirmative</strong></em> and <strong>negative</strong></em>, which say whether a word the
user typed is a positive or a negative answer respectively:
<pre>
affirmative(yes).
affirmative(y).
affirmative(ye).
affirmative(right).
affirmative(ok).
affirmative(uhhuh).
negative(no).
negative(n).
negative(not).
negative(never).
negative(impossible).
negative(haha).
</pre>
Then we can define a predicate <strong>askif</strong></em> of one input argument.  It will be
just like <strong>ask</strong></em> except it will have only one argument, the
question, and it will succeed if that question is answered
affirmatively and fail if the question is answered negatively.
We can also fix it so that if an answer is neither positive nor negative
(in other words, it is unclear), we will complain
and ask for another answer.
<pre>
askif(Q) :- ask(Q,A), positive_answer(A).
positive_answer(A) :- affirmative(A).
positive_answer(Qcode,A) :- not(negative(A)), not(affirmative(A)),
  write('Please answer yes or no.'), read(A2),
  retract(asked(Qcode,A)), asserta(asked(Qcode,A2)),
  affirmative(A2).
</pre>
We can also define:
<pre>
askifnot(Q) :- not(askif(Q)).
</pre>
which saves some parentheses.

<p>Users may not always understand a question.  We can let them
type a <strong>?</strong></em> instead of an answer, give them some explanatory text, and
provide them another chance to answer:
<pre>
ask(Q,A) :- asked(Q,A).
ask(Q,A) :- not(asked(Q,A)), write(Q), write('? '), read(A2),
  ask2(Q,A2,A).
ask2(Q,'?',A) :- explain(Q), ask(Q,A).
ask2(Q,A,A) :- not(A='?'), nl, asserta(asked(Q,A)).
</pre>
where <strong>explain</strong></em> facts store explanatory text.
Minor humanizing touches such as these can be immensely important to
user satisfaction, while imposing little on the programmer.

<p>
<h3>
Output coding
</h3>

<p>Another useful trick is to code questions, so we need not repeat
their text at each mention in the rules.  Codes for questions
also make rules easier to read, and help prevent mistakes
because it's
easy to err in typing a long string of text (and with caching,
every slightly different question is asked and cached separately).
For this we can use a predicate <strong>questioncode</strong></em> of two arguments,
a code word and a text string for the corresponding question.
Here's an example from appliance diagnosis:
<pre>
diagnosis('fuse blown') :- askif(device_dead), askif(lights_out).
diagnosis('fuse blown') :- askif(hear_pop).
diagnosis('break in cord') :- askif(device_dead),
  askif(cord_frayed).
questioncode(device_dead,'Does the device refuse to do anything').
questioncode(lights_out,
  'Do all the lights in the house seem to be off').
questioncode(hear_pop,'Did you hear a sound like a pop').
questioncode(cord_frayed,
  'Does the outer covering of the cord appear to be coming apart').
</pre>
To handle this, we must redefine <strong>ask</strong></em>:
<pre>
ask(Qcode,A) :- asked(Qcode,A).
ask(Qcode,A) :- not(asked(Qcode,A)), questioncode(Qcode,Q),
  write(Q), write('? '), read(A2), ask2(Q,Qcode,A2,A).
ask2(Q,Qcode,'?',A) :- explain(Qcode), ask(Qcode,A).
ask2(Q,Qcode,A,A) :- not(A='?'), asserta(asked(Qcode,A)).
</pre>

<p>A further refinement is to handle a class of related questions together.
We can do this by giving arguments to output codes, as for instance using
<strong>hear(X)</strong></em> to represent a question about hearing a sound <strong>X</strong></em>.  Then
to make the query we need
string concatenation, something unfortunately not available in most Prolog
dialects.  But there is a simple shortcut to concatenation by writing a
<strong>questioncode</strong></em> rule instead of a fact, that types extra words before
succeeding:
<pre>
questioncode(hear(X),X) :- write('Did you hear a sound like a ').
</pre>
So to ask if the user heard a pop sound you use:
<pre>
askif(hear(pop)).
</pre>
which prints on the terminal as:
<pre>
Did you hear a sound like a pop ?
</pre>

<p>Yet another coding trick is to code diagnoses.  This isn't as useful as
question coding, but helps when diagnoses are provable in many
different ways.  Diagnosis coding requires a new top-level predicate
that users must query instead of <strong>diagnosis</strong></em>, as:
<pre>
coded_diagnosis(D) :- diagnosis(X), diagnosis_code(X,D).
</pre>
For instance, we could use:
<pre>
diagnosis(fuse) :- ask('Does the device work at all',no),
  ask(Are the lights in the house off',yes).
diagnosis_code(fuse,'Fuse blown').
</pre>
Then we could get this behavior:
<pre>
?- coded_diagnosis(X).
Does the device work at all? no.
Are the lights in the house off? yes.
X=Fuse blown
</pre>

<p>
<h3>
Intermediate predicates
</h3>

<p>Building expert systems is straightforward when there are ten to a hundred
rules, each with one to three expressions on the right side.  But it can get
confusing when, as in a typical expert system today, there are thousands of
rules averaging ten expressions per right side.  It just gets too
difficult to keep
track of all the symbols used, and to determine everything necessary
for each rule.  The solution is to frequently use intermediate predicates,
predicates that occur on both the left and right sides of rules.  Intermediate
predicates can represent important simplifying generalizations about
groups of facts.
Viewing expert-system predicates as a hierarchy with diagnoses or final
conclusions at the top and
asked questions at the bottom, intermediate predicates are
everything in between.  Much of the intelligence and sophistication of expert
systems can come from a good choice of intermediate predicates
to reduce redundancy and simplify rules.

<p>A useful intermediate predicate with appliance diagnosis is <strong>power_problem</strong></em>,
a predicate that is true if the appliance is not getting any electricity for its innards.
It's useful because appropriate diagnoses when it is true are quite
different from those when it is false: a non-power problem must be in
the device itself and can't be in the cord or external fuse.
So <strong>power_problem</strong></em>
can go into many rules, typically early in the right side of the rule to
filter out inappropriate rule use.  But <strong>power_problem</strong></em> clearly
is an intermediate predicate, not a fact
we can establish from a single question, because
it has many different symptoms.  And some symptoms
are very strong, as when all the lights in the house
went off when you have tried to turn on the device, or when
the device stopped working when you moved its frayed cord slightly.

<p>Generally speaking, intermediate predicates are needed for any
important phenomena that aren't diagnoses.  Here are some more
ideas for intermediate predicates in appliance diagnosis:
<blockquote>
--whether the problem is mechanical;
<br>
--whether the problem is in a heating element;
<br>
--whether the appliance has had similar problems before;
<br>
--whether you can improve things by adjusting the controls or buttons;
<br>
--whether danger of electrocution is present;
<br>
--whether anything unusual was done to the appliance lately (like being
dropped or having liquids spilled on it);
<br>
--how much troubleshooting expertise the user has
(note that intermediate predicates can have arguments).
</blockquote>

<p>Intermediate-predicate expressions won't be arguments to <strong>askif</strong></em>s, since
they don't directly query a user.  Caching is a good idea
with intermediate predicates, even more so than caching of
query answers (as we did
with the <strong>ask</strong></em> predicate).  A single intermediate-predicate fact
can summarize many questions, and caching it saves having to ask all those
questions over again.  Nevertheless, caching of intermediate-predicate
conclusions should not
necessarily be automatic, as it only makes sense when a result might be reused.

<p>
<h3>
An example program
</h3>

<p>Let's put together the ideas we've introduced in this chapter in a larger
rule-based system for the diagnosis of malfunctions in small household
appliances.  Figure 7-1 shows some of the terminology, and Figure 7-2 gives
the predicate hierarchy.  We list rules in three groups: diagnosis (top-level)
rules, intermediate predicate rules, and question-decoding rules.
To get a diagnosis from this program, query <strong>diagnosis(X)</strong></em>.
Typing a semicolon will then give you an alternative diagnosis, if any;
and so on.  So if several things are wrong with the appliance, the program
will eventually find them all.
<pre>
/* Top-level diagnosis rules */
diagnosis('fuse blown') :- power_problem, askif(lights_out).
diagnosis('fuse blown') :- power_problem, askif(hear(pop)).
diagnosis('break in cord') :- power_problem, askif(cord_frayed).
diagnosis('short in cord') :- diagnosis('fuse blown'),
  askif(cord_frayed).
diagnosis('device not turned on') :- power_problem,
  klutz_user, askif(has('an on-off switch or control')),
  askif(device_on).
diagnosis('cord not in socket properly') :- power_problem,
  klutz_user, askif(just_plugged), askif(in_socket).
diagnosis('foreign matter caught on heating element') :-
  heating_element, not(power_problem), askif(smell_smoke).
diagnosis('appliance wet--dry it out and try again') :-
  power_problem, klutz_user, askif(liquids).
diagnosis('controls adjusted improperly') :- klutz_user,
  askif(has('knobs, switches, or other controls')).
diagnosis('kick it, then try it again') :- mechanical_problem.
diagnosis('throw it out and get a new one') :-
  not(power_problem), askif(hear('weird noise')).
diagnosis('throw it out and get a new one').
</pre>
<pre>
/* Definitions of intermediate predicates */
power_problem :- askif(device_dead), askif(has(knobs)),
askif(knobs_do_something).
power_problem :- askif(device_dead), askif(smell_smoke).
klutz_user :- askifnot(handyperson).
klutz_user :- askifnot(familiar_appliance).
mechanical_problem :- askif(hear('weird noise')),
  askif(has('moving parts')).
heating_element :- askif(heats).
heating_element :- askif(powerful).
</pre>
<pre>
/* Question decoding */
questioncode(device_dead,'Does the device refuse to do anything').
questioncode(knobs_do_something,
  'Does changing the switch positions or turning
  the knobs change anything').
questioncode(lights_out,
  'Do all the lights in the house seem to be off').
questioncode(cord_frayed,
  'Does the outer covering of the cord appear to be coming apart').
questioncode(handyperson,'Are you good at fixing things').
questioncode(familiar_appliance,
  'Are you familiar with how this appliance works').
questioncode(device_on,'Is the ON/OFF switch set to ON').
questioncode(just_plugged,'Did you just plug the appliance in').
questioncode(in_socket,'Is the cord firmly plugged into the socket').
questioncode(smell_smoke,'Do you smell smoke').
questioncode(liquids,
  'Have any liquids spilled on the appliance just now').
questioncode(heats,'Does the appliance heat things').
questioncode(powerful,'Does the appliance require a lot of power').
questioncode(has(X),X) :- write('Does the appliance have').
questioncode(hear(X),X) :- write('Did you hear a ').
</pre>
Here we use variables inside question codes for questions about components and
sounds heard.  We also use a <em>subdiagnosis</strong></em> ('fuse blown') as input to another
diagnosis, a useful trick.

<p>
<h3>
Running the example program
</h3>

<p>Here's an actual run of this program (which requires definitions of <strong>askif</strong></em>
and other predicates given earlier in this chapter).
Note the same diagnosis is
repeated when there are different ways to prove it.
<pre>
?- diagnosis(X).
Does the device refuse to do anything? yes.
Do all the lights in the house seem to be off? no.
Does the appliance have knobs or switches? yes.
Does changing the switch positions or turning
the knobs change anything? no.
Do you smell smoke? yes.
Does the appliance heat things? no.
Does the appliance require a lot of power? no.
Did you hear a pop? yes.
</pre>
<pre>

X=Fuse blown;

X=Fuse blown;

X=Fuse blown;
Are you good at fixing things? no.
Does the appliance have an on-off switch or control? yes.
Is the ON/OFF switch set to ON? no.

X=Device not turned on;
</pre>
<pre>
Are you familiar with how this appliance works? no.

X=Device not turned on;

X=Device not turned on;

X=Device not turned on;

X=Device not turned on;

X=Device not turned on;
</pre>
<pre>
Did you just plug the appliance in? yes.
Is the cord firmly plugged into the socket? no.

X=Cord not in socket properly;

X=Cord not in socket properly;

X=Cord not in socket properly;

X=Cord not in socket properly;

X=Cord not in socket properly;

X=Cord not in socket properly;
</pre>
<pre>
Have any liquids spilled on the appliance just now? maybe.
Please type yes or no. no.

X=Controls adjusted improperly;

X=Controls adjusted improperly;
Did you hear a weird noise? no.

X=Throw it out and get a new one;

no
?- halt.

</pre>

<p>
<h3>
Partitioned rule-based systems
</h3>

<p>Intermediate predicates group related rules together,
but they are only a conceptual grouping, more a help to understanding
and debugging programs.
A stronger way of grouping is putting
rules into partitions that can't "see" one another.  This is easy to do
with Prolog by putting rules in separate files and only loading
the files you need into the database.  Loading is done with the
<strong>consult</strong></em> built-in predicate in Prolog, a predicate of one argument which
is the name of the file to load.  So if the rule
<pre>
a :- b, c.
</pre>
is used for backward chaining, and we want whenever it succeeds
for the file "more" to be loaded, we should rewrite it as
<pre>
a :- b, c, consult(more).
</pre>
Like most built-in predicates, <strong>consult</strong></em> always fails on
backtracking since there's only one way to load a file.

<p>Often one partition is designated the "starting" partition, loaded
automatically when the rule-based system begins.  It then decides
which other partitions to load and invoke.  If a loaded partition
later decides it's not relevant (as when none of its rules fire), it
can itself load another partition and start that one running.

<p>
<h3>
Implementing the rule-cycle hybrid
</h3>

<p>Prolog's features make backward chaining easy.  But
it's also a general-purpose programming language, and can implement
quite different control structures.

<p>First consider the rule-cycle hybrid of backward and forward chaining,
easier to implement than pure forward chaining and hence
used in many simple expert systems.  It can be done by writing each rule in a
new form, a transformation of each backward chaining rule:
<blockquote>
1. "and" a new <strong>asserta</strong></em> on the right end of the right side of the
rule, whose argument is the left side of the rule;

<p>2. "and" a new <strong>not</strong></em> on the left end of the right side of the rule, with the same
argument;

<p>3. then replace the left side of the rule by <strong>r</strong></em> (first renaming any <strong>r</strong></em>
predicates already in the rules).
</blockquote>
So these backward chaining rules:
<pre>
a :- b.
c :- d, e, f.
</pre>
become:
<pre>
r :- not(a), b, asserta(a).
r :- not(c), d, e, f, asserta(c).
</pre>
And two sample rules from the appliance diagnosis program:
<pre>
diagnosis('fuse blown') :- power_problem, askif(lights_out).
power_problem :- askif(device_dead), askif(has(knobs)),
  askif(knobs_do_something).
</pre>
become:
<pre>
r :- not(diagnosis('fuse blown')), power_problem, askif(lights_out),
  asserta(diagnosis('fuse blown')).
r :- not(power_problem), askif(device_dead), askif(has(knobs)),
  askif(knobs_do_something), asserta(power_problem).
</pre>
(We'll discuss later how to convert automatically.)
So we replace our old rules with new rules whose only effect is caching
of particular conclusions.  Note that these new rules never call on other rules,
even if there are intermediate predicates, because <strong>r</strong></em> is the only left side
(since we made sure the predicate <strong>r</strong></em> doesn't occur in the rule-based system).
We'll assume for now that no predicate expressions in the original rules contain <strong>not</strong></em>s,
since they introduce complications.  If we really need negatives, we can
define fact predicates that stand for the opposite of other fact predicates.

<p>Now we must cycle through the rules; that is, consider each rule in order,
and go back to the first when we finish the last.  Within each pass, we
can force the Prolog interpreter to repeatedly backtrack to a
query of <strong>r</strong></em>.  A simple way is
<pre>
?- r, 1=2.
</pre>
Since the <strong>=</strong></em> can never be true, the interpreter will keep trying
<strong>r</strong></em> rules, regardless of whether they succeed or fail.  Eventually it will
run out of all <strong>r</strong></em> rules and fail.  Actually, there's a built-in Prolog predicate
called <strong>fail</strong></em> that has exactly the same effect as <strong>1=2</strong></em>, so we
can say equivalently
<pre>
?- r, fail.
</pre>
To give us a handle on this code, let's give it a name:
<pre>
one_cycle :- r, fail.
</pre>

<p>To get the Prolog interpreter to repeat indefinitely a cycle through the rules, we might
think that we could do the same <strong>fail</strong></em> trick, like
<pre>
hybrid :- one_cycle, fail.
</pre>
But this won't work because <strong>one_cycle</strong></em> won't ever return to the
<em>top</strong></em>
of the list of rules.  And <strong>one_cycle</strong></em> itself never succeeds, so the <strong>fail</strong></em> is
useless.  We could try
<pre>
hybrid :- not(one_cycle), fail.
</pre>
which answers the second objection but not the first: we need
each call to <strong>one_cycle</strong></em> to be a fresh call.  That suggests recursion:
<pre>
hybrid :- done.
hybrid :- not(one_cycle), hybrid.
</pre>
The <strong>done</strong></em> is a stopping condition that must be defined by the builder of
the rule-based system.  For diagnosis expert systems, it could be defined as
<pre>
done :- diagnosis(X).
</pre>
which says to stop whenever some diagnosis is proved.

<p>The preceding definition of <strong>hybrid</strong></em> only checks once per cycle
whether it is done.
To stop sooner, we could put the check inside <strong>one_cycle</strong></em> like this:
<pre>
hybrid :- done.
hybrid :- not(one_cycle), hybrid.
one_cycle :- r, done.
</pre>
But this requires more calls to <strong>done</strong></em>, not a good idea if <strong>done</strong></em> is
a complicated calculation.

<p>Note: this approach can handle <strong>not</strong></em>s in rules, though
differently from the algorithm in Section 6.4 since <strong>not</strong></em>s will be evaluated
on every cycle.  But as with the algorithm, any <strong>not</strong></em> must occur before any
rule with the argument to the <strong>not</strong></em> as its left side, or we'll get wrong
answers.

<p>
<h3>
Implementing pure forward chaining (*)
</h3>

<p>Pure forward chaining requires yet another rule form.
(See a Section 7.14 for how to rewrite rules automatically in
this form.)  Since pure forward chaining repeatedly
finds and "crosses out" expressions
on the right sides of rules, it would help to express rule right sides as
lists, for then we can use our <strong>member</strong></em> and <strong>delete</strong></em> list-processing predicates
from Chapter 5.
We can do this by making rules a kind of fact, say using a <strong>rule</strong></em>
predicate name.  The first argument to <strong>rule</strong></em> can be the left side of the
original rule, and the second argument the list of predicate expressions
"and"ed on the right side.  So these rules
<pre>
a :- b.
c :- d, e, f.
g(X) :- h(X,Y), not(f(Y)).
</pre>
become
<pre>
rule(a,[b]).
rule(c,[d,e,f]).
rule(g(X),[h(X,Y),not(f(Y))]).
</pre>
and the two sample rules from the appliance diagnosis program
<pre>
diagnosis('fuse blown') :- power_problem, askif(lights_out).
power_problem :- askif(device_dead), askif(has(knobs)),
  askif(knobs_do_something).
</pre>
become
<pre>
rule(diagnosis('fuse blown'),[power_problem,askif(lights_out)]).
rule(power_problem,
  [askif(device_dead),askif(has(knobs)),askif(knobs_do_something)]).
</pre>
For now, we'll assume that the rules don't contain <strong>not</strong></em>s.

<p>We also must represent facts.  Pure forward chaining requires that we
identify all facts, distinguishing them from rules.
We can do this by making each fact an argument to a predicate named
<strong>fact</strong></em>, of
one argument.  Then to bind <strong>F</strong></em> to every fact in turn, we query
<pre>
?- fact(F), done.
</pre>
which will backtrack repeatedly into <strong>fact</strong></em>.  For every fact <strong>F</strong></em>,
we must find the rules whose right sides can match it,
to derive new rules and possibly new facts.  This suggests:
<pre>
forward :- fact(F), not(pursuit(F)), done.
</pre>

<p>Unfortunately, we can't really implement "focus-of-attention" forward chaining
this way, since we can't insert new facts just after the last fact we selected,
only at the beginning (with <strong>asserta</strong></em>) and end (with <strong>assertz</strong></em>) of the
database.  To prevent fact
reuse, we can delete facts once pursued.
But deleted facts are still important to us (obtaining facts is the
whole point of forward chaining) so we'll copy
them into <strong>usedfact</strong></em> facts before we delete them.  The revised code:
<pre>
forward :- done.
forward :- fact(F), not(pursuit(F)), assertz(usedfact(F)),
  retract(fact(F)), forward.
</pre>
(Remember from Section 6.1 that <strong>retract</strong></em> removes a fact
from the database.)  Then when we're done,
all the things we learned plus all the starting facts
are in the database as arguments to the <strong>fact</strong></em> and <strong>usedfact</strong></em> predicates.

<p>The <strong>pursuit</strong></em> predicate can cycle through the rules like <strong>one_cycle</strong></em> did
in the hybrid implementation:
<pre>
pursuit(F) :- rule(L,R), rule_pursuit(F,L,R), fail.
</pre>
For <strong>rule_pursuit</strong></em> we must search through the right side of a rule,
deleting anything that matches the fact <strong>F</strong></em>; we can use
the <strong>member</strong></em> and <strong>delete</strong></em> predicates of Sections 5.5 and 5.6
respectively.  As you
may dimly recall, <strong>member</strong></em> checks whether an item is a member of a list, and
<strong>delete</strong></em> removes all occurrences of an item from a list.  We need them both
because <strong>delete</strong></em> always succeeds, and
we'd like to fail when a match doesn't occur in the list.
So (Figure 7-3):
<pre>
forward :- done.
forward :- fact(F), not(pursuit(F)), assertz(usedfact(F)),
  retract(fact(F)), forward.
pursuit(F) :- rule(L,R), rule_pursuit(F,L,R), fail.
rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew),
  new_rule(L,Rnew).
new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).
new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).
</pre>
The two <strong>new_rule</strong></em> lines say that when you've deleted everything on the right
side of a rule, the left side is a new fact; otherwise just write a
new, shorter and simpler rule.  And here again are <strong>member</strong></em> and <strong>delete</strong></em>:
<pre>
member(X,[X|L]).
member(X,[Y|L]) :- member(X,L).
delete(X,[],[]).
delete(X,[X|L],M) :- delete(X,L,M).
delete(X,[Y|L],[Y|M]) :- not(X=Y), delete(X,L,M).
</pre>

<p>As with the rule-cycle hybrid, you must define <strong>done</strong></em> appropriately.
If you want to make sure that all
possible conclusions are reached, use
<pre>
done :- not(fact(X)).
</pre>
which forces forward chaining to continue until there are no more
<strong>fact</strong></em> facts, in which case everything learned (as well as the initial facts)
is a <strong>usedfact</strong></em>. (Note this
rule violates our advice in Section 3.6 to avoid <strong>not</strong></em>s whose variables aren't
bound.  Here we want to stop if there's any unexamined fact <strong>X</strong></em> remaining, a kind
of existential quantification, so it makes sense.  A universally quantified
negation is equivalent to an existentially quantified unnegation; see
Appendix A.)   Alternatively,
<strong>done</strong></em> can be defined to mean that one of a set of "goal" facts have been
proved.

<p>The <strong>asserta</strong></em> in the first <strong>new_rule</strong></em> rule is important because it forces
focus-of-attention handling of new facts.  That is, the last fact found will
be the next fact pursued, like a stack data structure, because of the
recursion.  As we pointed out in the last chapter,
the focus-of-attention approach often reaches interesting conclusions fast.
If we change
<strong>asserta</strong></em> to <strong>assertz</strong></em>, we get a queue instead of a stack, with new facts
pursued only after old facts.

<p>Amazingly, the program works just fine when rules contain variables.
This is because the basis step (first line) in the <strong>member</strong></em> predicate
definition can bind variables to succeed, and when it does those variables
keep the same bindings through the rest of the rule.  If there is more
than one matching of a fact to a rule, the program will find each
by backtracking to <strong>member</strong></em>.  For instance, the rule
<pre>
rule(a(X,Y),[b(X,Y),b(Y,X),b(X,X)]).
</pre>
can match the fact <strong>b(tom,dick)</strong></em> to either the first or second predicate
expression on its right side, giving two new rules:
<pre>
rule(a(tom,dick),[b(dick,tom),b(tom,tom)]).
rule(a(dick,tom),[b(dick,tom),b(dick,dick)]).
</pre>

<p>When forward chaining with the preceding program is slow, a simple change
can often speed things up.  That is to delete the old rule when
a new rule is formed.  This speeds things up
because the sum of the number of rules, the number of <strong>fact</strong></em>s, and the number of
<strong>oldfact</strong></em>s stays constant instead of always increasing.  To do this, we
need only add a single expression to the <strong>rule_pursuit</strong></em> rule:
<pre>
rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew),
  retract(rule(L,R)), new_rule(L,Rnew).
</pre>
We can only do this safely for rule-based systems representable as
and-or-not lattices, where there are either no variables or only variables
that can take a single binding.  Otherwise deletion will throw
away still-possibly-useful rules, but this may not bother us if the odds
are small they're still useful.

<p>
<h3>
Forward chaining with "not"s (*)
</h3>

<p>As with hybrid chaining, we can avoid rules containing <strong>not</strong></em>s by
substituting "unfact" predicate names representing the
opposite of other predicate names.  Or we can require that arguments to <strong>not</strong></em>s
never be matchable to anything appearing on the left side of a
rule (DeMorgan's Laws can get the rules into this form; see
Appendix A).  Then we rewrite the top level of the program to handle
<strong>not</strong></em>s after it's done everything else:
<pre>
full_forward :- forward, handle_nots.
handle_nots :- rule(L,R), member(not(X),R), not(usedfact(X)),
  not(fact(X)), delete(not(X),R2), new_rule(L,R2), handle_nots.
handle_nots :- forward.
</pre>
This is not quite the algorithm in Section 6.2, but it's close.

<p>
<h3>
General iteration with "forall" and "doall" (*)
</h3>

<p>The iteration method of the rule-cycle hybrid and forward chaining programs
can be generalized.  First, suppose we want to check whether some predicate
expression <strong>Q</strong></em> succeeds for all possible variable values that satisfy some other
predicate expression <strong>P</strong></em>; that is, we want to
check <em>universal quantification</strong></em>
of <strong>Q</strong></em> with respect to <strong>P</strong></em>.  We can
do this by requiring that there be no way for <strong>Q</strong></em> to fail when <strong>P</strong></em> has
succeeded previously, taking into account any bindings.  We can use the
built-in <strong>call</strong></em> predicate of Prolog, which queries a predicate expression
given as argument:
<pre>
forall(P,Q) :- not(somefailure(P,Q)).
somefailure(P,Q) :- call(P), not(call(Q)).
</pre>
As an example, assume this database:
<pre>
a(1).
a(2).
b(1).
b(2).
c(1).
c(2).
c(3).
d(1,5).
d(5,1).
</pre>
Here are some example queries and their results:
<pre>
?- forall(a(X),b(X)).
yes
?- forall(b(X),c(X)).
yes
?- forall(c(X),b(X)).
no
?- forall(c(X),d(X,Y)).
no
?- forall(d(X,Y),d(Y,X)).
yes
</pre>

<p>Similarly, we can define a predicate that repeatedly backtracks into
predicate expression <strong>P</strong></em> until <strong>P</strong></em> fails:
<pre>
doall(P) :- not(alltried(P)).
alltried(P) :- call(P), fail.
</pre>
Assume this database:
<pre>
a(1).
a(2).
a(3).
u(X) :- a(X), write(X).
v(X) :- u(X), Y is X*X, write(Y), nl.
</pre>
Then here are two examples:
<pre>
?- doall(u(X)).
123
yes
?- doall(v(X)).
1
4
9
yes
</pre>
(Remember, <strong>write</strong></em> prints its argument on the terminal, and <strong>nl</strong></em> prints
a carriage return.)

<p>This <strong>doall</strong></em> is just what the forward chaining program accomplishes in the
<strong>pursuit</strong></em> predicate.  So we can rewrite the first four lines of the
forward chaining program as
<pre>
forward :- done.
forward :- fact(F), doall(pursuit(F)), assertz(usedfact(F)),
  retract(fact(F)), forward.
pursuit(F) :- rule(L,R), rule_pursuit(F,L,R).
</pre>
instead of
<pre>
forward :- done.
forward :- fact(F), not(pursuit(F)), assertz(usedfact(F)),
  retract(fact(F)), forward.
pursuit(F) :- rule(L,R), rule_pursuit(F,L,R), fail.
</pre>
And in the rule-cycle hybrid
<pre>
hybrid :- done.
hybrid :- doall(r), hybrid.
</pre>
can be used instead of
<pre>
hybrid :- done.
hybrid :- not(one_cycle), hybrid.
one_cycle :- r, fail.
</pre>
And the code for handling <strong>not</strong></em>s in forward chaining given in
Section 7.11 can be improved to
<pre>
full_forward :- forward, doall(handle_not), forward.
handle_not :- rule(L,R), member(not(X),R), not(usedfact(X)),
  not(fact(X)), delete(not(X),R2), new_rule(L,R2).
</pre>
instead of
<pre>
full_forward :- forward, handle_nots.
handle_nots :- rule(L,R), member(not(X),R), not(usedfact(X)),
  not(fact(X)), delete(not(X),R2), new_rule(L,R2), handle_nots.
handle_nots :- forward.
</pre>
The changes improve program readability.

<p>
<h3>
Input and output of forward chaining (*)
</h3>

<p>Fact pursuit is only part of what we need for forward chaining.
We must also handle input and output differently than with
backward chaining.  Backward chaining asked the user a question
whenever an answer was relevant to some conclusion under study.  This can
mean that many irrelevant questions are asked before backward chaining hits
on the right conclusions to try to prove.  Forward chaining, on the
other hand, focuses on a set of facts. The facts must get into the
database somehow to start things off.

<p>Two approaches are possible.  First, give a <em>questionnaire</strong></em>, a fixed set
of questions to a user presented one at a time, and code answers into facts.
Fixed questionnaires are common in the early part presented one at a time of
medical diagnosis, when a doctor tries to
get a broad picture of the health of a patient before moving on to specifics.
Second (especially if most possible facts don't have arguments),
give a <em>menu</strong></em>, a set of questions presented simultaneously to the user,
and ask which questions should be answered <strong>yes</strong></em>.  For diagnosis
applications, the menu can contain
common symptoms.  Menus are good when there are lots of possible
facts, few of which are simultaneously relevant to a case.

<p>Both are straightforward to implement in Prolog.
Questionnaires can be done by a fixed sequence of calls to the <strong>askif</strong></em>
predicate defined in Section 7.3.  The answer to each question
will cause the assertion of <strong>asked</strong></em> and <strong>fact</strong></em> facts.
Menus can be implemented by an <strong>ask_which</strong></em> predicate  | REFERENCE 1|:
.FS
 | REFERENCE 1| It's interesting to compare this program to the
forward-chaining program in Section 7.10: this represents more a Lisp style
of programming, with recursion through lists and no expectation of
backtracking.  The forward-chaining program represents more a Prolog style
of programming, with frequent backtracking and no lists.
.FE
<pre>
ask_which([A,B,C,D,E,F,G,H|L]) :-
screen_ask_which([A,B,C,D,E,F,G,H],[A,B,C,D,E,F,G,H]),
ask_which(L).
ask_which([]).
ask_which(L) :- length(L,N), N&lt;9, N&gt;0, screen_ask_which(L,L).
screen_ask_which([X|L],L2) :- length(L,N), length(L2,N2),
  N3 is N2 - N, write(N3), write(': '), questioncode(X,Q),
  write(Q), write('?'), nl, asserta(asked(X,no)),
screen_ask_which(L,L2).
screen_ask_which([],L2) :-
  write('Give numbers of questions whose answer is yes.'),
  read(AL), create_facts(AL,L2), nl.
create_facts([N|L],L2) :- item(N,L2,I), assertz(fact(I)),
  retract(asked(I,no)), asserta(asked(I,yes)), create_facts(L,L2).
create_facts([N|L],L2) :- not(item(N,L2,I)), create_facts(L,L2).
create_facts([],L2).
item(1,[X|L],X).
item(N,[X|L],I) :- N &gt; 1, N2 is N-1, item(N2,L,I).
member(X,[X|L]).
member(X,[Y|L]) :- member(X,L).
length([],1).
length([X|L],N) :- length(L,N2), N is N2+1.
</pre>
Here's an example use, assuming the <strong>questioncode</strong></em> definitions
for appliance diagnosis given earlier (Section 7.6):
<pre>
?- ask_which
([device_dead,knobs_do_something,lights_out,cord_frayed,
handyperson,familiar_appliance,device_on,just_plugged,in_socket,
smell_smoke,liquids,heats,powerful,has(knobs),has('moving parts'),
has('knobs, switches, or other controls'),
hear(pop),hear('weird noise')]).
1: Does the device refuse to do anything?
2: Does changing the switch positions or turning
the knobs change anything?
3: Do all the lights in the house seem to be off?
4: Does the outer covering of the cord appear to be
coming apart?
5: Are you good at fixing things?
6: Are you familiar with how this appliance works?
7: Is the ON/OFF switch set to ON?
8: Did you just plug the appliance in?
Give numbers of questions whose answer is yes.[3,4,5,7].
</pre>
<pre>
1: Is the cord firmly plugged into the socket?
2: Do you smell smoke?
3: Have any liquids spilled on the appliance just now?
4: Does the appliance heat things?
5: Does the appliance require a lot of power?
6: Does the appliance have knobs?
7: Does the appliance have moving parts?
8: Does the appliance have knobs, switches, or other controls?
Give numbers of questions whose answer is yes.[6,8].
</pre>
<pre>
1: Did you hear a pop?
2: Did you hear a weird noise?
Give numbers of questions whose answer is yes.[].
yes
</pre>
To verify that the correct facts were asserted, we can use Prolog's built-in
<strong>listing</strong></em> predicate that takes one argument, a predicate name, and prints out
every fact and rule with that name:
<pre>
?- listing(fact).
fact(device_dead).
fact(lights_out).
fact(cord_frayed).
fact(handyperson).
fact(device_on).
fact(has(knobs)).
fact(has('knobs, switches, or other controls')).
yes
</pre>

<p>Fact order is very important to the operation and hence the efficiency
of forward chaining (see Figure 6-3).  Furthermore, if your definition
of the <strong>done</strong></em> predicate is anything besides <strong>not(fact(X))</strong></em>, an incorrect
fact order may prevent all correct conclusions.  So it is a good idea to
order question presentation from most important to least important,
since facts are entered
with <strong>assertz</strong></em>.  To allow some user control, the preceding program asserts
choices for each individual menu in user-supplied order.  We set the menu size
to eight questions in the program, but you can easily change it if
you want to improve user control and your terminal screen is tall enough.

<p>For most applications, you shouldn't put every possible fact into
menus.  You should put the things most common in rules
in a first set of menus, and then run
forward chaining and see what conclusions you reach.  If no "interesting"
conclusions are reached (interestingness could mean
membership in a particular set), then present further menus to
the user (perhaps about things mentioned on the right sides of the
shortest remaining rules), assert new facts, and run forward chaining
again.  You can repeat the cycle as many times as you like.  This
is a <em>fact partitioning</strong></em> trick for rule-based systems, as opposed to the <em>rule
partitioning</strong></em> trick in Section 7.8.
For appliance repair for instance, the first menu could list
key classificatory information, such as whether it has a heating element,
whether it has mechanical parts, whether it gets electricity from an
outlet or from batteries, and what part of the appliance is faulty.
After forward chaining on these facts, further menus could obtain a detailed
description of the malfunction.

<p>Both menus and questionnaires should not "jump around" too much between topics
as backward chaining often does.  People are easily confused
by rapid shifts in subject, and asking related questions, even irrelevant
ones, makes them feel more comfortable.  Doctors know this.

<p>Ordering of output (conclusions) presentation is important too for forward
chaining.  Backward chaining just establishes one conclusion at a time,
but forward chaining may establish a whole lot of interesting conclusions
about some problem.  In fact this is one of its advantages, that it can
determine not one but multiple simultaneous problems are causing
observed symptoms.  If these conclusions are numerous,
it's good to sort them by a fixed priority ordering.

<p>
<h3>
Rule form conversions (*)
</h3>

<p>The rule forms needed for backward chaining, hybrid chaining, and forward
chaining are all different.  So it would be nice to automatically convert rules
from one form to another.  That means treating rules as data, something
important in many different areas of artificial intelligence, and
supported by most dialects of Prolog and Lisp.

<p>Prolog does this with the <strong>clause</strong></em> predicate in most dialects.
This has two arguments representing a left and a right side of a rule.
A query on <strong>clause</strong></em> succeeds if its arguments can match the
left and right sides of a database rule. (Remember, facts are rules without
left sides.)  So for instance
<pre>
?- clause(a,R).
</pre>
binds the variable <strong>R</strong></em> to the right side of the first rule it can find
that has <strong>a</strong></em> as its left side.  The arguments to <strong>clause</strong></em> can also be predicate
expressions containing arguments themselves.  So
<pre>
?- clause(p(X),R).
</pre>
will try to find a rule with a <strong>p</strong></em> predicate of one argument on its left
side, and will bind that one argument (if any) to the value of <strong>X</strong></em>, and
<strong>R</strong></em> to the query representing the right side of that rule | REFERENCE 2|.
.FS
 | REFERENCE 2| Many Prolog dialects require that the predicate name in the
first argument be bound, though arguments to that predicate name may
have variables.  If you have a list of all predicate names,
you can iterate over them to do this.
.FE

<p>Facts are just rules with no left sides.  And <strong>clause</strong></em> recognizes
this, also matching facts in the database as well as rules.  Then its
first argument is bound to the fact, and the right side is bound to the
word <strong>true</strong></em>.  For example, if for the preceding query we have a fact
<strong>p(a)</strong></em> in our database, one answer will be <strong>X=a</strong></em> with <strong>R</strong></em> bound to <strong>true</strong></em>.

<p>To automatically convert a rule to forward chaining form, we can
access it with <strong>clause</strong></em>, then convert the right side of the rule to
a list.  The second argument of the clause predicate is
bound to a query, not a list, so we need a list conversion
operation.  This is called "univ" and is symbolized in most
Prolog dialects by the infix predicate "<strong>=..</strong></em>", for which the stuff on the
left side is a predicate expression and the stuff on the right side is an
equivalent list.  So we can say
<pre>
?- clause(L,R), R =.. Rlist.
</pre>
and <strong>Rlist</strong></em> is a list, as we need for forward chaining.
Here's the full code for converting all rules in a Prolog database to
forward-chaining form:
<pre>
forward_convert :- clause(L,R), not(overhead_predicate(L)),
  R =.. Rlist, new_rule(L,Rlist), fail.
overhead_predicate(new_rule(X,Y)).
overhead_predicate(rule(X,Y)).
overhead_predicate(fact(X)).
new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).
new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).
overhead_predicate(forward_convert).
overhead_predicate(overhead_predicate(X)).
</pre>
If your Prolog dialect doesn't allow <strong>L</strong></em> to be unbound, you can use:
<pre>
forward_convert(All_predicates) :- member(L,All_predicates),
  forward_convert2(L).
forward_convert2(L) :- clause(L,R), R =.. Rlist, new_rule(L,Rlist), fail.
new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).
new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).
</pre>
and you must query <strong>forward_convert</strong></em> with a list of all the predicates
you want to convert.

<p>But all this won't work in some Prolog
dialects that treat commas and semicolons like infix operators.
If the preceding doesn't work for you, try:
<pre>
forward_convert(Preds) :- member(Pred,Preds), forward_convert2(Pred).
forward_convert2(Pred) :- clause(Pred,R), remove_commas(R,R2),
  new_rule(Pred,R2), fail.
remove_commas(true,[]).
remove_commas(S,[Y|L]) :- S=..[Comma,Y,Z], remove_commas(Z,L).
remove_commas(X,[X]) :- not(X=true), not(X=..[Comma,Y,Z]).
member(X,[X|L]).
member(X,[Y|L]) :- member(X,L).
new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).
new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).
</pre>

<p>We can apply the same approach to the hybrid control structure.  We convert
the right side of each backward-chaining rule to a list, insert a <strong>not</strong></em>
expression at the front of this list, insert an <strong>asserta</strong></em> expression
at the end of the list, and
replace the original left side with the single symbol <strong>r</strong></em>.  We then can use the
<strong>=..</strong></em> operation in reverse (the left side unbound and the right side bound),
converting the list of right-side expressions to a
query.  We enter this new rule into the Prolog database using
<strong>asserta</strong></em> with this new rule as argument.  Here's the full code:
<pre>
hybrid_convert :- clause(L,R), R =.. Rlist,
  add_last(asserta(L),Rlist,Rlist2),
  R2 =.. [not(L)|Rlist2], asserta(r :- R2), fail.
add_last(X,[],[X]).
add_last(X,[Y|L],[Y|L2]) :- add_last(X,L,L2).
</pre>
If your Prolog dialect doesn't allow <strong>L</strong></em> to be unbound, you can use:
<pre>
hybrid_convert(All_predicates) :- member(L,All_predicates),
  hybrid_convert2(L).
hybrid_convert2(L) :- clause(L,R), R =.. Rlist,
  add_last(asserta(L),Rlist,Rlist2),
  R2 =.. [not(L)|Rlist2], asserta(r :- R2), fail.
add_last(X,[],[X]).
add_last(X,[Y|L],[Y|L2]) :- add_last(X,L,L2).
</pre>
and if none of that works in your Prolog dialect, you can try this
alternative hybrid-chaining program
which doesn't directly convert Prolog rules but interprets them as needed:
<pre>
hybrid(Leftsidelist) :- done.
hybrid(Leftsidelist) :- not(one_cycle(Leftsidelist)), hybrid(Leftsidelist).
one_cycle(Leftsidelist) :- member(P,Leftsidelist), clause(P,R),
remove_commas(R,R2), allfacts(R2), not(P), asserta(P), fail.
member(X,[X|L]).
member(X,[Y|L]) :- member(X,L).
remove_commas(true,[]).
remove_commas(S,[Y|L]) :- S=..[Comma,Y,Z], remove_commas(Z,L).
remove_commas(X,[X]) :- not(X=true), not(X=..[Comma,Y,Z]).
allfacts([]).
allfacts([Term|L]) :- clause(Term,true), allfacts(L).
</pre>

<p>
<h3>
Indexing of predicates (*)
</h3>

<p>Prolog interpreters automatically index predicate names appearing on the left
sides of rules, to help in backward chaining; that is, they keep lists
of pointers
to all rules with a particular predicate name, to speed finding them.
But this won't help our rule-cycle hybrid and forward chaining implementations,
for which we must do our own indexing if we want efficiency.

<p>Let's take pure forward chaining as an example.  Indexing
could mean storing for each predicate name a list of which rule <em>right</strong></em>
sides it appears in.  One way is to generalize the <strong>rule</strong></em> predicate
of Section 7.10 to a <strong>rules</strong></em> predicate whose first argument is a predicate
expression <strong>P</strong></em> and whose second argument is a list of pairs
representing rules containing <strong>P</strong></em> on their right side.  The first item of
each pair is a rule left side, and the second item is a rule right side
containing the specified predicate name.  So the rules
<pre>
a :- b, c.
d :- c, e, f.
</pre>
are written as
<pre>
rules(b,[[a,[b,c]]]).
rules(c,[[a,[b,c]],[d,[c,e,f]]]).
rules(e,[[d,[c,e,f]]]).
rules(f,[[d,[c,e,f]]]).
</pre>
and just changing <strong>pursuit</strong></em>, the forward chaining program becomes:
<pre>
forward :- done.
forward :- fact(F), doall(pursuit(F)), assertz(usedfact(F)),
retract(fact(F)), forward.
pursuit(F) :- rules(F,Rlist), member([L,R],Rlist), rule_pursuit(F,L,R).
rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew), new_rule(L,Rnew).
new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).
new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).
</pre>
A rule with K expressions on its right side is repeated K times this way, so
this indexing buys speed at the expense of space.  The speed advantage
comes from eliminating the <strong>member</strong></em> predicate in the earlier
implementation; we have cached in advance the results of
running <strong>member</strong></em>.

<p>Clever indexing techniques have been developed in both artificial
intelligence and database research, and much further can be done along these
lines.

<p>
<h3>
Implementing meta-rules (*)
</h3>

<p>Meta-rules are rules that treat rules as data, usually by choosing the one
to use next (<em>conflict resolution</strong></em>).  Choosing means treating
rules as data.  So meta-rule implementation needs special rule formats
like those for hybrid and pure-forward chaining, and can exploit <strong>clause</strong></em>
and <strong>=..</strong></em> for rule-form conversion.  We can represent meta-rules as
rules with a special <strong>prefer</strong></em> predicate name on their left sides.  The <strong>prefer</strong></em>
will take four arguments: the left side of a rule 1, the right side of rule 1
(as a list), the left side of a rule 2, and the right side of rule 2 (as a
list).  It should succeed when rule 1 is preferable (to execute next) to
rule 2.  (Of course, none of your regular rules can have a <strong>prefer</strong></em>
predicate name for this to work.)
Here's an example:
<pre>
prefer(L1,R1,L2,R2) :- length(R1,Len1), length(R2,Len2),
Len1 &lt; Len2.
</pre>
This says a rule with shorter right side should be preferred.  Predicate
<strong>length</strong></em> was defined in Section 5.5, and computes the number of items in a list:
<pre>
length([],0).
length([X|L],N) :- length(L,N2), N is N2 + 1.
</pre>
Another example:
<pre>
prefer(a(X),R1,a(Y),R2) :- member(b(Z),R1), not(member(b(W),R2)).
</pre>
This says that if two rules both conclude something about one-argument
predicate <strong>a</strong></em>, one is preferred if it mentions one-argument predicate
fact for the second) concluding about a one-argument predicate <strong>a</strong></em>, whether
their arguments are constants or variables.

<p>Meta-rules are most useful when they refer, unlike these two examples,
to the current state of reasoning rather than the unvarying text of rules.
As an example, consider this meta-rule to be used with pure
forward chaining:
<pre>
prefer(L1,R1,L2,R2) :- member(b,R1), not(member(b,R2)), fact(b).
</pre>
This says to prefer a rule that mentions predicate expression
<strong>b</strong></em> to one that doesn't, whenever
<strong>b</strong></em> was proved a fact.  A more useful meta-rule says to prefer
the rule used most recently:
<pre>
prefer(L1,R1,L2,R2) :- used(L1,R1,T1), used(L2,R2,T2), T1 &gt; T2.
</pre>
Here we assume <strong>used</strong></em> is a fact asserted after each successful rule application,
stating the time a rule was used (times can be increasing integers).
Such meta-rules permit flexible control adjustable to the
processing context, something general-purpose control structures
can't do by themselves.

<p>Programmers can write these meta-rules at the same time they
write the rules for an application.  The set of meta-rules can
express a lattice of orderings (or <em>partial ordering</strong></em>) of rule preferences,
but not necessarily a complete ordering or sorting.  So
it's possible for neither of two rules to be preferred to the other, in
which case we can pick one arbitrarily.

<p>Meta-rules enhance general-purpose control structures, and aren't
a control structure by themselves.  This means that meta-rule implementation is
different for backward, hybrid, and forward chaining.  With
backward chaining, meta-rules pick a rule or fact (not necessarily
the first in database order) to try to match to a predicate expression
in a query or rule
right side.  With hybrid chaining, meta-rules pick a rule from the
entire set of rules to run next.  With pure forward chaining, meta-rules
can both select a fact to try next and select a rule to try to match the
fact to.
As an example, here's an implementation of meta-rules with hybrid chaining.
<pre>
metahybrid :- done.
metahybrid :- pick_rule(R), call(R), metahybrid.
pick_rule(R) :- clause(r,R), not(better_rule(R)).
better_rule(R) :- clause(r,R2), prefer(r,R2,r,R).
</pre>
This assumes rules are written in the standard hybrid form with <strong>r</strong></em> on the
left side and the two extra things on the right side.  Rules are repeatedly
executed (using the <strong>call</strong></em> predicate, which executes a query as if it were
typed in) until the <strong>done</strong></em> condition is satisfied.
A rule is chosen to execute only if no other rules are preferred to it
according to the meta-rules.

<p>
<h3>
Implementing concurrency (*)
</h3>

<p>Several Prolog dialects provide for concurrency of rules and
expressions in rules.  The emphasis is programmer's tools
to indicate good places to do concurrency rather than
automatic choice.  For instance, a special "and" symbol, used in place
of a comma, can specify "and"-parallelism on the right side of a rule.
These approaches to concurrency are complicated
and incompatible with each other, and we won't discuss them here.

<p>
<h3>
Decision lattices: a compilation of a rule-based system (*)
</h3>

<p>Compilers and compilation are important concepts in computer science.
Compilers take a program in an easy-to-read but slow-to-execute form and
convert it to a more efficient, easier-to-interpret form.
Compilation is often rule-based itself, especially
often-complicated <em>code optimization</strong></em>.  But
compilation techniques can also make artificial
intelligence programs themselves more efficient.  Since
rule-based systems are further steps
in power beyond traditional higher-level languages like Pascal, Ada, PL/1, and
Fortran, secondary compilations are usually done before the primary
compilation to machine language.  These secondary compilations
convert rules to the format of those languages:
formats without references to backward, forward, or hybrid chaining,
and with no backtracking, no postponing of variable bindings, and no
multiway designation of inputs and outputs to predicate expressions.  The
decision lattice representation of rules introduced in Section 6.8
is one such secondarily-compiled format.  It starts at some
node in a lattice, and depending on how a user answers a question, it
those to some next node in the lattice.  Each question represents
another branch point.  When it gets to a node that is a <em>leaf</strong></em> (a node from
which it cannot go any further), it retrieves the conclusion associated
with that node.

<p>A decision lattice for a set of rules can be created systematically
(albeit not algorithmically, since it involves some subjective judgment)
from rules without "or"s on their right sides, by the following (similar
to "automatic indexing" methods):
<blockquote>
1. For every top-level or <strong>diagnosis</strong></em> rule, repeatedly substitute in the
definitions for (right sides of) all intermediate predicates on its
right side, until no more remain.  If there is more than one rule proving an
intermediate predicate, make multiple versions of the diagnosis rule, one
for each possibility.  (This is a useful compilation method
even if you don't want a decision lattice; it's called
<em>rule collapsing</strong></em>.)

<p>2. Examine the right sides of the new rules.  Pick a predicate expression that
appears unnegated in some rules and negated in an approximately equal
number (the more rules it appears in, the better, and the more even
the split, the better).  Call this the partitioning predicate expression,
and have
the first question to the user ask about it.  Create branches from the
starting node to new nodes, each corresponding to a possible
answer to this question.  Partition the rules into groups
corresponding to the answers, and associate each group with one new node
(copies of rules not mentioning the predicate expression should be put into
every group).  Then remove all occurrences of the expression and its
negation from the rules.  Now within each rule group, separately apply this step
recursively, choosing a predicate that partitions the remaining
rules in the group best, and taking its questioning next.
</blockquote>

<p>An example will make this clearer.  Suppose we have facts, <strong>a</strong></em>, <strong>b</strong></em>, <strong>c</strong></em>,
<strong>d</strong></em>, and <strong>e</strong></em>,
and possible diagnoses (final conclusions) <strong>r</strong></em>, <strong>s</strong></em>, <strong>t</strong></em>,<strong>u</strong></em>, and <strong>v</strong></em>.
Suppose these are the rules:
<pre>
r :- a, d, not(e).
s :- not(a), not(c), q.
t :- not(a), p.
u :- a, d, e.
u :- a, q.
v :- not(a), not(b), c.
p :- b, c.
p :- not(c), d.
q :- not(d).
</pre>
For the first step (preprocessing), we substitute in the
intermediate predicates <strong>p</strong></em> and <strong>q</strong></em>.  (Intermediate predicates are just
anything that occurs on both a left and a right side.)
<pre>
r :- a, d, not(e).
s :- not(a), not(c), not(d).
t :- not(a), b, c.
t :- not(a), not(c), d.
u :- a, d, e.
u :- a, not(d).
v :- not(a), not(b), c.
</pre>
For the second step we first examine right sides of rules to find
something mentioned in a lot of rules that partitions them evenly as possible.
Expression <strong>a</strong></em> is the obvious choice, because it is the only expression
occurring in every rule.  So we partition on <strong>a</strong></em>, deleting it from the rules,
getting two rule sets:
<pre>
r :- d, not(e).  /* Subdatabase for "a" true */
u :- d, e.
u :- not(d).
</pre>
<pre>
s :- not(c), not(d).  /* Subdatabase for "not(a)" true */
t :- b, c.
t :- not(c), d.
v :- not(b), c.
</pre>
The first set will be used whenever the fact <strong>a</strong></em> is true, and the second
set will be used whenever the fact <strong>a</strong></em> is false.  In the first group <strong>d</strong></em>
appears in all rules, so it can be the partitioning expression.
Likewise, <strong>c</strong></em> can partition the second group.  This gives four rule groups
or <em>subdatabases</strong></em>:
<pre>
r :- not(e).		/* The "a, d" rule subdatabase */
u :- e.
</pre>
<pre>
u.			/* The "a, not(d)" subdatabase */
</pre>
<pre>
t :- b.			/* The "not(a), c" subdatabase */
v :- not(b).
</pre>
<pre>
s :- not(d).		/* The "not(a), not(c)" subdatabase */
t :- d.
</pre>
Three of the four groups are two-rule, for which
one more partitioning gives a unique answer.  The final
decision lattice created by this analysis is shown in Figure 7-4.

<p>Decision lattice compilations of rule-base systems can be easily written
in any computer language, including Prolog.
Give code names to every node in the decision lattice,
including the starting and ending nodes.  Then define a <strong>successor</strong></em> predicate
of two arguments that gives conditions for one node
to be followed by another node.  For instance, for our previous example:
<pre>
successor(n1,n2) :- askif(a).
successor(n1,n3) :- askifnot(a).
successor(n2,n4) :- askif(d).
successor(n4,u) :- askif(e).
successor(n4,r) :- askifnot(e).
successor(n2,u) :- askifnot(d).
successor(n3,n5) :- askif(c).
successor(n5,t) :- askif(b).
successor(n5,v) :- askifnot(b).
successor(n3,n6) :- askifnot(c).
successor(n6,t) :- askif(d).
successor(n6,s) :- askifnot(d).
</pre>
Then we query a new <strong>diagnosis</strong></em> predicate defined:
<pre>
diagnosis(Node,Node) :- not(successor(Node,X)).
diagnosis(D,Start) :- successor(Start,X), diagnosis(D,X).
</pre>
For the preceding example we also need a way to query the facts:
<pre>
questioncode(X,X) :- member(X,[a,b,c,d]), write('Is this correct: ').
member(X,[X|L]).
member(X,[Y|L]) :- member(X,L).
</pre>
And here's what happens:
<pre>
?- diagnosis(X,n1).
Is this correct: a? no.
Is this correct: c? yes.
Is this correct: b? no.
X=v;
no
</pre>

<p>This program is a simple example of "search" programs, which we'll
study in much more detail in Chapters 9, 10, and 11.

<p>
<h3>
Summary of the code described in the chapter (*)
</h3>

<p>Warning: in using the following,
make sure your own code does not redefine or even duplicate the definitions of
any predicates used, or you can be in serious trouble.

<p>The following rules assist question-asking for backward,
forward, and hybrid chaining.  The <strong>ask</strong></em> predicate
asks the user a question, providing extra explanation if the user
types a question mark, and returns the answer (after caching it).
The <strong>questioncode</strong></em> and <strong>explain</strong></em> predicates must be provided by
the programmer; the first decodes questions, and the second provides
additional explanation for particular questions when the user has
trouble understanding.  The <strong>askif</strong></em> predicate handles yes/no questions;
it succeeds if the user answers positively, fails if the user answers
negatively, and requests another answer if the user answers anything else.
Warning: do <strong>abolish(asked,2))</strong></em> to erase memory before a new situation
(problem), if you want to solve more than one situation.
<pre>
/* Tools for questioning the user */
askif(Qcode) :- ask(Qcode,A), positive_answer(Qcode,A).
askifnot(Qcode) :- not(askif(Qcode)).

<p>positive_answer(Qcode,A) :- affirmative(A).
positive_answer(Qcode,A) :- not(negative(A)),
  not(affirmative(A)), write('Please answer yes or no.'),
  read(A2), retract(asked(Qcode,A)),
  asserta(asked(Qcode,A2)), affirmative(A2).

<p>ask(Qcode,A) :- asked(Qcode,A).
ask(Qcode,A) :- not(asked(Qcode,A)), questioncode(Qcode,Q),
  write(Q), write('? '), read(A2), ask2(Q,Qcode,A2,A).

<p>ask2(Q,Qcode,'?',A) :- explain(Qcode), ask(Qcode,A).
ask2(Q,Qcode,A,A) :- not(A='?'), asserta(asked(Qcode,A)).
</pre>
<pre>
affirmative(yes).
affirmative(y).
affirmative(ye).
affirmative(right).
affirmative(ok).
affirmative(uhhuh).

<p>negative(no).
negative(n).
negative(not).
negative(never).
negative(impossible).
negative(haha).
</pre>

<p>To do rule-cycle hybrid chaining, write the rules with <strong>r</strong></em> on their
left sides, and an <strong>asserta</strong></em> of the original left side on the right
end of the right side.  No rules can contain <strong>not</strong></em>.
Then query <strong>hybrid</strong></em>, using this program:
<pre>
/* Problem-independent rule-cycle hybrid chaining */
hybrid :- done.
hybrid :- doall(r), hybrid.

<p>doall(P) :- not(alltried(P)).

<p>alltried(P) :- call(P), fail.
</pre>

<p>To do pure forward chaining, write the rules as facts with predicate
name <strong>rule</strong></em>, for which the first argument is a left side and the second
argument is the corresponding right side.  No rules can contain <strong>not</strong></em>.
Then query <strong>forward</strong></em>, defined this way:
<pre>
/* Problem-independent forward chaining */
forward :- done.
forward :- fact(F), doall(pursuit(F)), assertz(usedfact(F)),
 retract(fact(F)), forward.

<p>pursuit(F) :- rule(L,R), rule_pursuit(F,L,R).

<p>rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew),
  new_rule(L,Rnew).

<p>new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).
new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).

<p>doall(P) :- not(alltried(P)).

<p>alltried(P) :- call(P), fail.

<p>member(X,[X|L]).
member(X,[Y|L]) :- member(X,L).

<p>delete(X,[],[]).
delete(X,[X|L],M) :- delete(X,L,M).
delete(X,[Y|L],[Y|M]) :- not(X=Y), delete(X,L,M).
</pre>
When this program stops, the learned facts are left as assertions
of <strong>fact</strong></em> and <strong>usedfact</strong></em> predicates.  If you want to make sure that all
possible conclusions are reached, use this definition of <strong>done</strong></em>:
<pre>
done :- not(fact(X)).
</pre>

<p>If you want to speed up forward chaining, and your rule-based system
can be represented as an and-or-not lattice, you can rewrite the preceding
<strong>rule_pursuit</strong></em> rule as:
<pre>
rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew), retract(rule(L,R)),
  new_rule(L,Rnew).
</pre>

<p>If you want to do forward chaining with predicate expressions having <strong>not</strong></em>s,
first make sure the <strong>not</strong></em>s all refer to fact predicates.  Then
execute <strong>full_forward</strong></em>:
<pre>
full_forward :- forward, doall(handle_not), forward.

<p>handle_not :- rule(L,R), member(not(X),R), not(usedfact(X)),
  not(fact(X)), delete(not(X),R2), new_rule(L,R2).
</pre>

<p>Meta-rules can enhance other control structures.  They can be written
as rules with predicate name <strong>prefer</strong></em>, of four arguments (the left and
right sides of two rules, respectively) that give conditions under which
the first rule should be executed before the second rule.  For meta-rules
with hybrid chaining, execute the query <strong>metahybrid</strong></em> with this alternative
code:
<pre>
/* Problem-independent rule-cycle hybrid chaining using meta-rules */
metahybrid :- done.
metahybrid :- pick_rule(R), call(R), metahybrid.

<p>pick_rule(R) :- clause(r,R), not(better_rule(R)).

<p>better_rule(R) :- clause(r,R2), prefer(r,R2,r,R).
</pre>

<p>To implement menus as a way of getting facts to do forward chaining,
execute <strong>ask_which</strong></em> with argument the list of question codes for the facts
you want to check.
<pre>
/* Menu generation for forward chaining */
ask_which([A,B,C,D,E,F,G,H|L]) :-
  screen_ask_which([A,B,C,D,E,F,G,H],[A,B,C,D,E,F,G,H]),
  ask_which(L).
ask_which([]).
ask_which(L) :- length(L,N), N&lt;9, N&gt;0, screen_ask_which(L,L).

<p>screen_ask_which([X|L],L2) :- length(L,N), length(L2,N2),
  N3 is N2 - N, write(N3), write(': '), questioncode(X,Q),
  write(Q), write('?'), nl, asserta(asked(X,no)),
  screen_ask_which(L,L2).
screen_ask_which([],L2) :-
  write('Give numbers of questions whose answer is yes.'),
  read(AL), create_facts(AL,L2), nl.

<p>create_facts([N|L],L2) :- item(N,L2,I), assertz(fact(I)),
  retract(asked(I,no)), asserta(asked(I,yes)), create_facts(L,L2).
create_facts([N|L],L2) :- not(item(N,L2,I)), create_facts(L,L2).
create_facts([],L2).

<p>item(1,[X|L],X).
item(N,[X|L],I) :- N &gt; 1, N2 is N-1, item(N2,L,I).

<p>member(X,[X|L]).
member(X,[Y|L]) :- member(X,L).

<p>length([],1).
length([X|L],N) :- length(L,N2), N is N2+1.
</pre>

<p>To implement a decision lattice, draw the lattice and label all the
nodes with unique names.  Write rules defining the branches with
the <strong>successor</strong></em> predicate, for example
<pre>
successor(n5,n9) :- askif(device_dead).
successor(n5,n15) :- askifnot(device_dead).
</pre>
which says that if you're at node n5, go to node n9 if the user responds
positively to the <strong>device_dead</strong></em> question, otherwise go to node n15.
Then to run the decision lattice call <strong>diagnosis(D,&lt;first-node&gt;)</strong></em>,
which needs this definition:
<pre>
diagnosis(D,Start) :- successor(Start,X), diagnosis(D,X).
diagnosis(Node,Node) :- not(successor(Node,X)).
</pre>

<p>
<h2>
Keywords:
</h2>

<p>
<pre>
<em>diagnosis
character string
input coding
output coding
intermediate predicates
menu</strong></em>
</pre>

<p>.SH
</em></strong>
Exercises

<p>7-1. (R,A,P) Improve the appliance-diagnosis program given in Section 7.6
so it can reach the following new diagnoses:
<blockquote>
--the motor has burned out, for appliances that have motors;
<br>
--something is blocking the mechanical operation (like something keeping
the motor from turning), for mechanical appliances;
<br>
--some internal wiring is broken (possible if appliance was dropped recently,
or some other jarring occurred);
</blockquote>
Add new questions and perhaps intermediate predicates to handle these
diagnoses.  Show your new program working.

<p>7-2. (A,P) Figure out a simple way to prevent repeated printing of
the same diagnosis in the backward-chaining appliance program as in
Section 7.7.  Show your method working on the appliance program.

<p>7-3. (E) (a) Medical records often reference very-high-level and very-low-level
concepts only, no intermediate concepts.  Is this typical of other
expert-system application areas?

<p>(b) Suppose you must defend intermediate concepts in an expert system
to your boss or
representative of a funding agency.  They could claim that intermediate
concepts don't add capabilities to an expert system, just make its innards
neater.  Furthermore, intermediate concepts require
extra design effort, and slow down
operation by forcing reasoning to proceed by smaller steps. How would you
reply in defense of intermediate predicates?

<p>7-4. (P,H,G) Design a rule-based expert system to give debugging advice about
Prolog programs.  Use backward chaining in the manner of the appliance
example, asking questions of the user.  There is a lot of room for
creativity in the choice of what the program knows about, but the program
must help debug Prolog programs in some way.
Be sure:
<blockquote>
1. Your program is a rule-based expert system:

<p>2. Your program contains at least 20 diagnosis rules (rules
drawing a conclusion about what is wrong with a Prolog program),
12 of which have more than one kind of evidence "and"ed
on their right side;

<p>3. Your program uses at least three intermediate conclusions,
conclusions that are neither equivalent to facts nor correspond to
advice to the user;

<p>4. Your program can reach at least seven different conclusions
depending on the user's answers to the questions;

<p>5. Three of the conclusions your program reaches appear on the left
side of more than one rule (that is, there must be multiple paths to three
conclusions);

<p>6. Your program uses at least three kinds of history information,
like how long the user has been programming Prolog, or
whether parts of the user's program are already debugged;

<p>7. The control structure of your program is not extensively "hard-wired"
(for instance, there can't be a lot of branch specifications controlling
where to go next);

<p>8. As much as possible, all the variables and predicate names are semantically
meaningful (that is, their function should be explained by their names; use
numbers in your program only for (possibly) probabilities).
</blockquote>
Use of probabilities or certainty factors is not necessary.
Think about good ways to present your conclusions to the user.

<p>7-5. (A) (For people who know something about probabilities.)  Caching of facts
in backward chaining is not always a good idea; it depends on the situation.
Suppose we have rules for testing whether <strong>a(X)</strong></em> is true for some <strong>X</strong></em>,
rules that require R units of time to execute on the average.  Suppose to
speed things up we cache K values of <strong>X</strong></em> for which the <strong>a</strong></em> predicate holds.
That is, we place facts for those values in front of the rules
that calculate <strong>a(X)</strong></em> as previously.  Then to answer a query on the <strong>a</strong></em>
predicate, we first sequentially search through all these cached facts,
and use the rules only if we can't find a match in the cache.

<p>(a) Suppose the probability is P that any one item in the cache matches an
incoming query, and suppose the cache items are all different and do not
have variables, so if one item matches the query no other item will.
Under what approximate conditions will using the cache be
preferable to not using the cache?  Assume that |K &lt; 0.1 / P|, and assume that
each cache access requires one unit of time.

<p>(b) Now assume the items of the cache are not all equally likely to be used.
Often a <em>Zipf's Law</strong></em> distribution applies, for which the probability of the
most common item is P, the probability of the second most common item is P/2,
the probability of the third most common item is P/3, and so on.  Again
assume cache items are mutually exclusive.
Again assume that each cache access requires one unit of time.
Under what approximate conditions is caching desirable now?  Hint: the
sum of |1 / I| from |I = 1| to |K| is approximately |log sub 2 ( K + 1 )|.

<p>7-6. (P) Write a rule-based expert system to recommend cleaning methods for
clothing.  Obtain rules from a human "expert" on the subject.  Use hybrid
chaining in implementation for simplicity.  Ask the user to
give a single category that best describes the material they want to clean, and
then ask additional questions as necessary to make its description more
precise.  Write at least twenty rules reaching at least ten
different cleaning methods as conclusions.  Use a lot of <strong>a_kind_of</strong></em> facts to
classify the many kinds of clothing.  You'll need to worry about rule order,
and default rules will help.

<p>7-7. The criteria for when to delete a rule in forward chaining were
conservative: they miss other circumstances under which it would
be good to delete rules.  Define those circumstances, and explain how
we could efficiently check for them.

<p>7-8. (H,P) Write a program to diagnose malfunctions of a car using forward
chaining in the pure form.  Write at least fifty rules and use at
least ten intermediate predicates.  Use a repair manual as your source
of expertise.  Concentrate on some particular
subsystem of the car to do a better job.  Use the menu approach
to defining facts.  Provide for at least two invocations of forward
chaining, and stop when one of a set of <strong>diagnosis</strong></em> facts is proved.

<p>7-9. (H,P) Write a rule-based expert system to diagnose simple illnesses and
medical problems (such as a "primary care" or "family practice" physician
might handle).  Use a medical reference book as your source of knowledge.
Your program should be able to reach 30 different diagnoses, at
least seven in more than one way, using at least five intermediate predicates.
Run your rules with both backward chaining and forward chaining and
compare performance.  To do this, use the automatic conversion routines,
or use the forward-chaining rule form and write your own backward-chainer.
For forward chaining, let the user pick symptoms
from a series of menus, and ask questions of the user directly for additional
secondary facts.  Show your rules working on sample situations.

<p>7-10. (P) Write a rule-based expert system to choose a good way to graphically
display data.  Suppose as input this program loads a file of
<strong>data</strong></em> facts of one argument, a list representing properties
of some object.  Suppose the output is a recommendation about whether to
use bar graphs, pie graphs, two-dimensional plots, summary tables, etc.
for particular positions in the data list.  For instance, a recommendation
might be to plot all the first items of data lists as an X coordinate against
second items as a Y coordinate, and to draw a bar graph showing all the
first items against third items.  These graphing recommendations will need
to pick subsidiary information about ranges to be plotted, binning (what
values get grouped together), approximate dimensions of the display,
extra lines, unusual values (<em>outliers</strong></em>) that have been
left out, etc.  Generally you can find some
graphical display for every pair of data item positions, but
only some of these will be interesting and worth recommending.  Interestingness
can be defined in various ways, but should emphasize the unpredictability
of the data: a nearly straight line makes an uninteresting graph.  It will be
useful to define a number of processing predicates, including a <strong>column</strong></em>
predicate that makes a list of all the data values in position K in the data
list, and predicate that applies a standard statistical test
(look one up in a statistics book) to see if the values in two such columns
are associated or correlated.  You may want to consult a book giving
recommendations for graphical display.

<p>7-11. (A) The definitions of the <strong>forall</strong></em> and <strong>doall</strong></em> predicates both use the
built-in Prolog predicate <strong>call</strong></em>, which takes a predicate expression as
argument and queries it.  (This is useful because the argument can
be a variable bound within a program.)  Use <strong>call</strong></em> to implement the
following:

<p>(a) <strong>or(P,Q)</strong></em> which succeeds whenever querying either <strong>P</strong></em> or <strong>Q</strong></em> succeeds

<p>(b) <strong>if(P,Q,R)</strong></em> which succeeds whenever <strong>P</strong></em> succeeds then <strong>Q</strong></em> succeeds, or
if <strong>P</strong></em> fails then <strong>R</strong></em> succeeds

<p>(c) <strong>case(P,N,L)</strong></em> which succeeds whenever predicate expression
number <strong>N</strong></em> of list <strong>L</strong></em> succeeds, where <strong>N</strong></em> is bound by executing predicate
expression <strong>P</strong></em> (that is <strong>N</strong></em> must be a variable in <strong>P</strong></em> that is bound by <strong>P</strong></em>)

<p>7-12. (H,P) Implement the other hybrid of backward and forward chaining
mentioned in Section 6.4, the hybrid that alternates between forward and
backward chaining.  Show your program working on some sample rules and facts.

<p>7-13. (P) Implement meta-rules for pure forward chaining.  Use a
<strong>prefer</strong></em> predicate like the one used for rule-cycle hybrid meta-rules.

<p>7-14. (P) Consider meta-rules with pure forward chaining (the implementation is
considered in Exercise 7-13).  Assume there are no variables in the rules.

<p>(a) Write a meta-rule to prevent the same conclusion from being reached twice.

<p>(b) Write a meta-rule, and a little additional code to
that written for Exercise 7-13, to prevent the same rule from being
used twice in a row.

<p>7-15. Convert the appliance-diagnosis program to a decision lattice.  Try
to minimize the number of questions required to a user.

<p>7-16. (H,P,G) Write a rule-based system that, given the syllables of an
English sentence in phonemic representation, figures out which syllables to
stress.  Such stress rules are relatively straightforward and can be found
in many linguistics books.  You'll need list-processing techniques
from Chapter 5, and you must worry about the order the stress rules
are applied.

<p>7-17. (P) Write a program to give simple navigation commands to
a mobile robot moving across a battlefield.  Assume the battlefield
is divided into squares, designated by integer X and Y coordinates
ranging from X=0 to X=50 and from Y=0 to Y=50; the robot is not allowed
to leave this area.  The robot starts at location somewhere on the
Y=0 line and it is trying to get to location (50,30).
There are impassible bomb craters at (20,10), (10,25), and (20,40),
all circles of radius 2.  There is an impassible ravine extending along the
Y=30 line from X=10 to X=50.

<p>The robot begins moving at time 0.  The rule-based system to control
it should order one of only four actions: move one unit north, move one
unit south, move one unit east, and move one unit west.  Each move
takes one unit of time.  At time T=15 a bomb crater appears 4 units
north of the robot; at T=25 a crater appears 3 units west; at T=30
a crater appears 3 units east; and at T=40 a crater appears 4 units east.

<p>The robot should not be able to "see" craters and ravines until it is
just at their edges.  But suppose the robot knows the coordinates of
the goal location and its current coordinates at all times, so it
always knows where it is.  Try to specify the robot's actions in
general terms, that will work for any configuration of craters and ravines.

<p>Try your program out with the robot starting at various locations along Y=0.

<p>7-18. (E) Like most rule-based expert systems, our appliance diagnosis system
doesn't reason about causal chains.  In other words, it knows that a
certain pattern of symptoms signal an underlying cause, but it
doesn't know
<em>why</strong></em>
the cause leads to the symptoms, the exact chains of cause and effect
that explain each particular symptom.  For instance, it knows that when
a device isn't working at all, there might be a short in the cord; but it
doesn't know the reason is that a short causes the resistance of a
cord to be significantly lowered, causing a lot of electricity
to flow into the cord, causing a lot of electricity to flow through a
fuse, causing the metal conductor in the fuse to heat up, causing it
to melt, causing the metal to flow, causing it to break the electrical
connection, causing no electricity to go to the appliance cord, causing
the appliance to not work at all.  For what kinds of appliances and
diagnosis circumstances could this lack of causal-chain reasoning be a
problem?  (We should use a quite different rule-based system then.)  In what
sense can the appliance expert system of this chapter be seen as a
simplification of a more general kind of expert system?

<p>
<p><A HREF="book.html">Go to book index</A>
</body>
</html>
